###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/Aug/2015  14:25:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\fatfs_drv.c
#    Command line =  
#        "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\fatfs_drv.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM322xG_EVAL -lcN
#        "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\List\"
#        -o "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\Obj\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.20.2\arm\INC\c\DLib_Config_Full.h" -I "D:\Sample Code\Manta\2015 ARM
#        Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\Devices\STM32F2xx\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Core\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\STM32_EVAL\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\STM32_EVAL\Common\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\STM32_EVAL\STM322xG_EVAL\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\Third_Party\fat_fs\inc\"
#        -Oh --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.20.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\List\fatfs_drv.lst
#    Object file  =  
#        D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\Obj\fatfs_drv.o
#
###############################################################################

D:\Sample Code\Manta\2015 ARM Design Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\fatfs_drv.c
      1          /**
      2            ******************************************************************************
      3            * @file    fatfs_drv.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0RC4
      6            * @date    21-December-2012
      7            * @brief   diskio interface
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include <stdio.h>
     30          #include <stdlib.h>
     31          #include <string.h>
     32          
     33          #include "diskio.h"
     34          #if defined (STM32F2XX)
     35           #include "stm322xg_eval_sdio_sd.h"
     36          #elif defined (STM32F4XX)
     37           #include "stm324xg_eval_sdio_sd.h"
     38          #elif defined (STM32F10X_HD)
     39           #include "stm3210e_eval_sdio_sd.h"
     40          #endif
     41          
     42          /* Private typedef -----------------------------------------------------------*/
     43          /* Private define ------------------------------------------------------------*/
     44          //#define USE_FS_RTC                 1
     45          #define BLOCK_SIZE                 512 /* Block Size in Bytes */
     46          /* Private macro -------------------------------------------------------------*/
     47          /* Private variables ---------------------------------------------------------*/
     48          
     49          static volatile DSTATUS Stat = STA_NOINIT;	/* Disk status */
     50          
     51          /* Private function prototypes -----------------------------------------------*/
     52          /* Private functions ---------------------------------------------------------*/
     53          
     54          
     55          /**
     56             * @brief  Initialize Disk Drive  
     57             * @param   drv : driver index
     58             * @retval DSTATUS : operation status
     59            */
     60          
     61          DSTATUS disk_initialize ( BYTE drv )
     62          {
     63            
     64            NVIC_InitTypeDef NVIC_InitStructure;  
     65            Stat = STA_NOINIT;
     66            
     67            if (drv == 0)
     68            {
     69              NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
     70              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     71              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     72              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     73              NVIC_Init(&NVIC_InitStructure);
     74              
     75              NVIC_InitStructure.NVIC_IRQChannel = SD_SDIO_DMA_IRQn;
     76              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
     77              NVIC_Init(&NVIC_InitStructure);
     78              
     79              if( SD_Detect() == SD_PRESENT)
     80              {
     81                Stat &= ~STA_NOINIT;
     82              }     
     83            }
     84            
     85            return Stat;
     86          }
     87          
     88          /**
     89             * @brief  Get Disk Status  
     90             * @param   drv : driver index
     91             * @retval DSTATUS : operation status
     92          */
     93          DSTATUS disk_status ( BYTE drv	)
     94          {  
     95            Stat = STA_NOINIT;
     96            
     97            if (drv == 0) 
     98            {
     99              if (SD_Detect() != SD_PRESENT)
    100              {
    101                  Stat |= STA_NODISK;
    102              }
    103              
    104              if(SD_GetStatus() == 0)
    105              {
    106                Stat &= ~STA_NOINIT;
    107              }
    108            }
    109            
    110            return Stat;  
    111          }
    112          
    113          /**
    114             * @brief  Read Sector(s) 
    115             * @param   drv : driver index
    116             * @retval DSTATUS : operation status
    117            */
    118          DRESULT disk_read (
    119                             BYTE drv,			/* Physical drive number (0) */
    120                             BYTE *buff,			/* Pointer to the data buffer to store read data */
    121                             DWORD sector,		/* Start sector number (LBA) */
    122                             BYTE count			/* Sector count (1..255) */
    123                               )
    124          {
    125            uint32_t timeout  = 100000;
    126            DWORD  scratch [BLOCK_SIZE / 4] ;  // Alignment ensured, need enough stack
    127            SD_Error sdstatus = SD_OK;
    128           
    129            if (drv == 0)
    130            {
    131                  if (SD_Detect() != SD_PRESENT)
    132                  {
    133                    return(RES_NOTRDY);
    134                  }
    135          
    136                  if ((DWORD)buff & 3) // DMA Alignment issue, do single up to aligned buffer
    137                  {
    138                    while (count--)
    139                    {
    140                      SD_ReadBlock((BYTE *)scratch, (uint32_t )((sector + count) * BLOCK_SIZE) ,BLOCK_SIZE);
    141                      /* Check if the Transfer is finished */
    142                      sdstatus = SD_WaitReadOperation();
    143                      
    144                      while(SD_GetStatus() != SD_TRANSFER_OK)
    145                      {
    146                        
    147                        if (timeout-- == 0)
    148                        {
    149                          return RES_ERROR;
    150                        }
    151                      }
    152                      memcpy (&buff[count * BLOCK_SIZE] ,scratch, BLOCK_SIZE);
    153                    }
    154                  }
    155                  else
    156                  {
    157                    SD_ReadMultiBlocks((BYTE *)buff, (uint32_t )(sector * BLOCK_SIZE), BLOCK_SIZE, count);
    158                    
    159                    /* Check if the Transfer is finished */
    160                    sdstatus = SD_WaitReadOperation();
    161                    
    162                    while(SD_GetStatus() != SD_TRANSFER_OK)
    163                    {
    164                      
    165                      if (timeout-- == 0)
    166                      {
    167                        return RES_ERROR;
    168                      }
    169                    }
    170                  }
    171                  if (sdstatus == SD_OK)
    172                  {
    173                    return RES_OK;
    174                  }
    175            }
    176            return RES_ERROR;
    177          }
    178          /**
    179             * @brief  write Sector(s) 
    180             * @param   drv : driver index
    181             * @retval DSTATUS : operation status
    182            */
    183          
    184          #if _READONLY == 0
    185          DRESULT disk_write (
    186                              BYTE drv,			/* Physical drive number (0) */
    187                              const BYTE *buff,	/* Pointer to the data to be written */
    188                              DWORD sector,		/* Start sector number (LBA) */
    189                              BYTE count			/* Sector count (1..255) */
    190                                )
    191          {
    192            uint32_t timeout  = 100000;
    193            DWORD  scratch [BLOCK_SIZE / 4] ;  // Alignment ensured, need enough stack 
    194            SD_Error sdstatus = SD_OK;
    195            
    196            if (drv == 0)
    197            {
    198                
    199                if (SD_Detect() != SD_PRESENT)
    200                {
    201                  return(RES_NOTRDY);
    202                }
    203                  
    204                if ((DWORD)buff & 3) // DMA Alignment issue, do single up to aligned buffer
    205                {
    206                  while (count--)
    207                  {
    208                    memcpy (scratch, &buff[count * BLOCK_SIZE], BLOCK_SIZE);
    209                    
    210                    SD_WriteBlock((BYTE *)scratch, (uint32_t )((sector + count) * BLOCK_SIZE), BLOCK_SIZE);
    211                    
    212                    /* Check if the Transfer is finished */
    213                    sdstatus = SD_WaitWriteOperation();
    214                    
    215                    while(SD_GetStatus() != SD_TRANSFER_OK)
    216                    {
    217                      if (timeout-- == 0)
    218                      {
    219                        return RES_ERROR;
    220                      }
    221                    }
    222                  }
    223                }
    224                else
    225                {
    226                  SD_WriteMultiBlocks((BYTE *)buff, (uint32_t )(sector * BLOCK_SIZE), BLOCK_SIZE, count);
    227                  /* Check if the Transfer is finished */
    228                  sdstatus = SD_WaitWriteOperation();
    229                  while(SD_GetStatus() != SD_TRANSFER_OK)
    230                  {
    231                    if (timeout-- == 0)
    232                    {
    233                      return RES_ERROR;
    234                    }
    235                  }
    236                }
    237                if (sdstatus == SD_OK)
    238                {
    239                  return RES_OK;
    240                }
    241            }
    242            return RES_ERROR;
    243          }
    244          #endif /* _READONLY == 0 */
    245          
    246          
    247          /**
    248             * @brief  I/O control operation
    249             * @param   drv : driver index
    250             * @retval DSTATUS : operation status
    251            */
    252          
    253          
    254          #if _USE_IOCTL != 0
    255          DRESULT disk_ioctl (
    256                              BYTE drv,		/* Physical drive number (0) */
    257                              BYTE ctrl,		/* Control code */
    258                              void *buff		/* Buffer to send/receive control data */
    259                                )
    260          {
    261            DRESULT res;
    262            SD_CardInfo SDCardInfo;    
    263            
    264            if (drv) return RES_PARERR;
    265            
    266            res = RES_ERROR;
    267            
    268            if (Stat & STA_NOINIT) return RES_NOTRDY;
    269            
    270            switch (ctrl) {
    271            case CTRL_SYNC :		/* Make sure that no pending write process */
    272              
    273              res = RES_OK;
    274              break;
    275              
    276            case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
    277              if(drv == 0)
    278              {
    279                SD_GetCardInfo(&SDCardInfo);  
    280                *(DWORD*)buff = SDCardInfo.CardCapacity / 512; 
    281              }
    282              
    283              res = RES_OK;
    284              break;
    285              
    286            case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
    287              *(WORD*)buff = 512;
    288              res = RES_OK;
    289              break;
    290              
    291            case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
    292              if(drv == 0)
    293                *(DWORD*)buff = 512;
    294              else
    295                *(DWORD*)buff = 32;
    296              
    297              
    298              break;
    299              
    300              
    301            default:
    302              res = RES_PARERR;
    303            }
    304            
    305            
    306            
    307            return res;
    308          }
    309          #endif /* _USE_IOCTL != 0 */
    310          /**
    311             * @brief  Get Time from RTC
    312             * @param   None
    313             * @retval Time in DWORD
    314            */
    315          
    316          DWORD get_fattime (void)
    317          {
    318            return 0;
    319          }
    320          
    321          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   disk_initialize
        16   -> NVIC_Init
        16   -> SD_Detect
      96   disk_ioctl
        96   -> SD_GetCardInfo
     544   disk_read
       544   -> SD_Detect
       544   -> SD_GetStatus
       544   -> SD_ReadBlock
       544   -> SD_ReadMultiBlocks
       544   -> SD_WaitReadOperation
       544   -> __aeabi_memcpy
       8   disk_status
         8   -> SD_Detect
         8   -> SD_GetStatus
     544   disk_write
       544   -> SD_Detect
       544   -> SD_GetStatus
       544   -> SD_WaitWriteOperation
       544   -> SD_WriteBlock
       544   -> SD_WriteMultiBlocks
       544   -> __aeabi_memcpy
       0   get_fattime


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      10  ?Subroutine0
       1  Stat
      76  disk_initialize
      84  disk_ioctl
     150  disk_read
      44  disk_status
     146  disk_write
       4  get_fattime

 
   1 byte  in section .data
 522 bytes in section .text
 
 522 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
