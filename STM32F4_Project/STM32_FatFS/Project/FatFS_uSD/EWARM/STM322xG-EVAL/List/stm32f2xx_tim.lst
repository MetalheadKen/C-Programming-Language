###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/Aug/2015  14:26:03
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_tim.c
#    Command line =  
#        "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_tim.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM322xG_EVAL -lcN
#        "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\List\"
#        -o "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\Obj\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.20.2\arm\INC\c\DLib_Config_Full.h" -I "D:\Sample Code\Manta\2015 ARM
#        Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\Devices\STM32F2xx\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Core\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\STM32_EVAL\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\STM32_EVAL\Common\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\STM32_EVAL\STM322xG_EVAL\"
#        -I "D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\..\..\..\Utilities\Third_Party\fat_fs\inc\"
#        -Oh --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.20.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\List\stm32f2xx_tim.lst
#    Object file  =  
#        D:\Sample Code\Manta\2015 ARM Design
#        Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Project\FatFS_uSD\EWARM\STM322xG-EVAL\Obj\stm32f2xx_tim.o
#
###############################################################################

D:\Sample Code\Manta\2015 ARM Design Contest\STM32_FatFS_Example_V1.0.0RC4\STM32_FatFS_Example_V1.0.0RC4\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.1.2
      6            * @date    05-March-2012 
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Advanced-control timers (TIM1 and TIM8) specific features  
     13            *            - Interrupts, DMA and flags management
     14            *            - Clocks management
     15            *            - Synchronization management
     16            *            - Specific interface management
     17            *            - Specific remapping management      
     18            *              
     19            *  @verbatim
     20            *  
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *          This driver provides functions to configure and program the TIM 
     25            *          of all STM32F2xx devices.
     26            *          These functions are split in 9 groups: 
     27            *   
     28            *          1. TIM TimeBase management: this group includes all needed functions 
     29            *             to configure the TM Timebase unit:
     30            *                   - Set/Get Prescaler
     31            *                   - Set/Get Autoreload  
     32            *                   - Counter modes configuration
     33            *                   - Set Clock division  
     34            *                   - Select the One Pulse mode
     35            *                   - Update Request Configuration
     36            *                   - Update Disable Configuration
     37            *                   - Auto-Preload Configuration 
     38            *                   - Enable/Disable the counter     
     39            *                 
     40            *          2. TIM Output Compare management: this group includes all needed 
     41            *             functions to configure the Capture/Compare unit used in Output 
     42            *             compare mode: 
     43            *                   - Configure each channel, independently, in Output Compare mode
     44            *                   - Select the output compare modes
     45            *                   - Select the Polarities of each channel
     46            *                   - Set/Get the Capture/Compare register values
     47            *                   - Select the Output Compare Fast mode 
     48            *                   - Select the Output Compare Forced mode  
     49            *                   - Output Compare-Preload Configuration 
     50            *                   - Clear Output Compare Reference
     51            *                   - Select the OCREF Clear signal
     52            *                   - Enable/Disable the Capture/Compare Channels    
     53            *                   
     54            *          3. TIM Input Capture management: this group includes all needed 
     55            *             functions to configure the Capture/Compare unit used in 
     56            *             Input Capture mode:
     57            *                   - Configure each channel in input capture mode
     58            *                   - Configure Channel1/2 in PWM Input mode
     59            *                   - Set the Input Capture Prescaler
     60            *                   - Get the Capture/Compare values      
     61            *                   
     62            *          4. Advanced-control timers (TIM1 and TIM8) specific features
     63            *                   - Configures the Break input, dead time, Lock level, the OSSI,
     64            *                      the OSSR State and the AOE(automatic output enable)
     65            *                   - Enable/Disable the TIM peripheral Main Outputs
     66            *                   - Select the Commutation event
     67            *                   - Set/Reset the Capture Compare Preload Control bit
     68            *                              
     69            *          5. TIM interrupts, DMA and flags management
     70            *                   - Enable/Disable interrupt sources
     71            *                   - Get flags status
     72            *                   - Clear flags/ Pending bits
     73            *                   - Enable/Disable DMA requests 
     74            *                   - Configure DMA burst mode
     75            *                   - Select CaptureCompare DMA request  
     76            *              
     77            *          6. TIM clocks management: this group includes all needed functions 
     78            *             to configure the clock controller unit:
     79            *                   - Select internal/External clock
     80            *                   - Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx
     81            *         
     82            *          7. TIM synchronization management: this group includes all needed 
     83            *             functions to configure the Synchronization unit:
     84            *                   - Select Input Trigger  
     85            *                   - Select Output Trigger  
     86            *                   - Select Master Slave Mode 
     87            *                   - ETR Configuration when used as external trigger   
     88            *     
     89            *          8. TIM specific interface management, this group includes all 
     90            *             needed functions to use the specific TIM interface:
     91            *                   - Encoder Interface Configuration
     92            *                   - Select Hall Sensor   
     93            *         
     94            *          9. TIM specific remapping management includes the Remapping 
     95            *             configuration of specific timers               
     96            *   
     97            *  @endverbatim
     98            *    
     99            ******************************************************************************
    100            * @attention
    101            *
    102            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
    103            *
    104            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    105            * You may not use this file except in compliance with the License.
    106            * You may obtain a copy of the License at:
    107            *
    108            *        http://www.st.com/software_license_agreement_liberty_v2
    109            *
    110            * Unless required by applicable law or agreed to in writing, software 
    111            * distributed under the License is distributed on an "AS IS" BASIS, 
    112            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    113            * See the License for the specific language governing permissions and
    114            * limitations under the License.
    115            *
    116            ******************************************************************************
    117            */
    118          
    119          /* Includes ------------------------------------------------------------------*/
    120          #include "stm32f2xx_tim.h"
    121          #include "stm32f2xx_rcc.h"
    122          
    123          /** @addtogroup STM32F2xx_StdPeriph_Driver
    124            * @{
    125            */
    126          
    127          /** @defgroup TIM 
    128            * @brief TIM driver modules
    129            * @{
    130            */
    131          
    132          /* Private typedef -----------------------------------------------------------*/
    133          /* Private define ------------------------------------------------------------*/
    134          
    135          /* ---------------------- TIM registers bit mask ------------------------ */
    136          #define SMCR_ETR_MASK      ((uint16_t)0x00FF) 
    137          #define CCMR_OFFSET        ((uint16_t)0x0018)
    138          #define CCER_CCE_SET       ((uint16_t)0x0001)  
    139          #define	CCER_CCNE_SET      ((uint16_t)0x0004) 
    140          #define CCMR_OC13M_MASK    ((uint16_t)0xFF8F)
    141          #define CCMR_OC24M_MASK    ((uint16_t)0x8FFF) 
    142          
    143          /* Private macro -------------------------------------------------------------*/
    144          /* Private variables ---------------------------------------------------------*/
    145          /* Private function prototypes -----------------------------------------------*/
    146          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    147                                 uint16_t TIM_ICFilter);
    148          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    149                                 uint16_t TIM_ICFilter);
    150          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    151                                 uint16_t TIM_ICFilter);
    152          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    153                                 uint16_t TIM_ICFilter);
    154          
    155          /* Private functions ---------------------------------------------------------*/
    156          
    157          /** @defgroup TIM_Private_Functions
    158            * @{
    159            */
    160          
    161          /** @defgroup TIM_Group1 TimeBase management functions
    162           *  @brief   TimeBase management functions 
    163           *
    164          @verbatim   
    165           ===============================================================================
    166                                 TimeBase management functions
    167           ===============================================================================  
    168            
    169                 ===================================================================      
    170                        TIM Driver: how to use it in Timing(Time base) Mode
    171                 =================================================================== 
    172                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    173                 
    174                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    175                              
    176                 2. Fill the TIM_TimeBaseInitStruct with the desired parameters.
    177                 
    178                 3. Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure the Time Base unit
    179                    with the corresponding configuration
    180                    
    181                 4. Enable the NVIC if you need to generate the update interrupt. 
    182                    
    183                 5. Enable the corresponding interrupt using the function TIM_ITConfig(TIMx, TIM_IT_Update) 
    184                 
    185                 6. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    186                       
    187                 Note1: All other functions can be used separately to modify, if needed,
    188                    a specific feature of the Timer. 
    189          
    190          @endverbatim
    191            * @{
    192            */
    193            
    194          /**
    195            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    196            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    197            * @retval None
    198          
    199            */
    200          void TIM_DeInit(TIM_TypeDef* TIMx)
    201          {
    202            /* Check the parameters */
    203            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    204           
    205            if (TIMx == TIM1)
    206            {
    207              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    208              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
    209            } 
    210            else if (TIMx == TIM2) 
    211            {     
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    213              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    214            }  
    215            else if (TIMx == TIM3)
    216            { 
    217              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    218              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    219            }  
    220            else if (TIMx == TIM4)
    221            { 
    222              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    223              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    224            }  
    225            else if (TIMx == TIM5)
    226            {      
    227              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    228              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    229            }  
    230            else if (TIMx == TIM6)  
    231            {    
    232              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    233              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    234            }  
    235            else if (TIMx == TIM7)
    236            {      
    237              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    238              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    239            }  
    240            else if (TIMx == TIM8)
    241            {      
    242              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    243              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
    244            }  
    245            else if (TIMx == TIM9)
    246            {      
    247              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    248              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
    249             }  
    250            else if (TIMx == TIM10)
    251            {      
    252              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    253              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
    254            }  
    255            else if (TIMx == TIM11) 
    256            {     
    257              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    258              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
    259            }  
    260            else if (TIMx == TIM12)
    261            {      
    262              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    263              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
    264            }  
    265            else if (TIMx == TIM13) 
    266            {       
    267              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    268              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
    269            }  
    270            else
    271            { 
    272              if (TIMx == TIM14) 
    273              {     
    274                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    275                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    276              }   
    277            }
    278          }
    279          
    280          /**
    281            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    282            *         the specified parameters in the TIM_TimeBaseInitStruct.
    283            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    284            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
    285            *         that contains the configuration information for the specified TIM peripheral.
    286            * @retval None
    287            */
    288          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    289          {
    290            uint16_t tmpcr1 = 0;
    291          
    292            /* Check the parameters */
    293            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    294            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    295            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    296          
    297            tmpcr1 = TIMx->CR1;  
    298          
    299            if((TIMx == TIM1) || (TIMx == TIM8)||
    300               (TIMx == TIM2) || (TIMx == TIM3)||
    301               (TIMx == TIM4) || (TIMx == TIM5)) 
    302            {
    303              /* Select the Counter Mode */
    304              tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    305              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    306            }
    307           
    308            if((TIMx != TIM6) && (TIMx != TIM7))
    309            {
    310              /* Set the clock division */
    311              tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    312              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    313            }
    314          
    315            TIMx->CR1 = tmpcr1;
    316          
    317            /* Set the Autoreload value */
    318            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    319           
    320            /* Set the Prescaler value */
    321            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    322              
    323            if ((TIMx == TIM1) || (TIMx == TIM8))  
    324            {
    325              /* Set the Repetition Counter value */
    326              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    327            }
    328          
    329            /* Generate an update event to reload the Prescaler 
    330               and the repetition counter(only for TIM1 and TIM8) value immediatly */
    331            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
    332          }
    333          
    334          /**
    335            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    336            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    337            *         structure which will be initialized.
    338            * @retval None
    339            */
    340          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    341          {
    342            /* Set the default configuration */
    343            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
    344            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    345            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    346            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    347            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
    348          }
    349          
    350          /**
    351            * @brief  Configures the TIMx Prescaler.
    352            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    353            * @param  Prescaler: specifies the Prescaler Register value
    354            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    355            *          This parameter can be one of the following values:
    356            *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    357            *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
    358            * @retval None
    359            */
    360          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
    361          {
    362            /* Check the parameters */
    363            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    364            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    365            /* Set the Prescaler value */
    366            TIMx->PSC = Prescaler;
    367            /* Set or reset the UG Bit */
    368            TIMx->EGR = TIM_PSCReloadMode;
    369          }
    370          
    371          /**
    372            * @brief  Specifies the TIMx Counter Mode to be used.
    373            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    374            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    375            *          This parameter can be one of the following values:
    376            *            @arg TIM_CounterMode_Up: TIM Up Counting Mode
    377            *            @arg TIM_CounterMode_Down: TIM Down Counting Mode
    378            *            @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    379            *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    380            *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    381            * @retval None
    382            */
    383          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
    384          {
    385            uint16_t tmpcr1 = 0;
    386          
    387            /* Check the parameters */
    388            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    389            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    390          
    391            tmpcr1 = TIMx->CR1;
    392          
    393            /* Reset the CMS and DIR Bits */
    394            tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
    395          
    396            /* Set the Counter Mode */
    397            tmpcr1 |= TIM_CounterMode;
    398          
    399            /* Write to TIMx CR1 register */
    400            TIMx->CR1 = tmpcr1;
    401          }
    402          
    403          /**
    404            * @brief  Sets the TIMx Counter Register value
    405            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    406            * @param  Counter: specifies the Counter register new value.
    407            * @retval None
    408            */
    409          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    410          {
    411            /* Check the parameters */
    412             assert_param(IS_TIM_ALL_PERIPH(TIMx));
    413          
    414            /* Set the Counter Register value */
    415            TIMx->CNT = Counter;
    416          }
    417          
    418          /**
    419            * @brief  Sets the TIMx Autoreload Register value
    420            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    421            * @param  Autoreload: specifies the Autoreload register new value.
    422            * @retval None
    423            */
    424          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    425          {
    426            /* Check the parameters */
    427            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    428            
    429            /* Set the Autoreload Register value */
    430            TIMx->ARR = Autoreload;
    431          }
    432          
    433          /**
    434            * @brief  Gets the TIMx Counter value.
    435            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    436            * @retval Counter Register value
    437            */
    438          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    439          {
    440            /* Check the parameters */
    441            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    442          
    443            /* Get the Counter Register value */
    444            return TIMx->CNT;
    445          }
    446          
    447          /**
    448            * @brief  Gets the TIMx Prescaler value.
    449            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    450            * @retval Prescaler Register value.
    451            */
    452          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    453          {
    454            /* Check the parameters */
    455            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    456          
    457            /* Get the Prescaler Register value */
    458            return TIMx->PSC;
    459          }
    460          
    461          /**
    462            * @brief  Enables or Disables the TIMx Update event.
    463            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    464            * @param  NewState: new state of the TIMx UDIS bit
    465            *          This parameter can be: ENABLE or DISABLE.
    466            * @retval None
    467            */
    468          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    472            assert_param(IS_FUNCTIONAL_STATE(NewState));
    473          
    474            if (NewState != DISABLE)
    475            {
    476              /* Set the Update Disable Bit */
    477              TIMx->CR1 |= TIM_CR1_UDIS;
    478            }
    479            else
    480            {
    481              /* Reset the Update Disable Bit */
    482              TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
    483            }
    484          }
    485          
    486          /**
    487            * @brief  Configures the TIMx Update Request Interrupt source.
    488            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    489            * @param  TIM_UpdateSource: specifies the Update source.
    490            *          This parameter can be one of the following values:
    491            *            @arg TIM_UpdateSource_Global: Source of update is the counter
    492            *                 overflow/underflow or the setting of UG bit, or an update
    493            *                 generation through the slave mode controller.
    494            *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
    495            * @retval None
    496            */
    497          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
    498          {
    499            /* Check the parameters */
    500            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    501            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
    502          
    503            if (TIM_UpdateSource != TIM_UpdateSource_Global)
    504            {
    505              /* Set the URS Bit */
    506              TIMx->CR1 |= TIM_CR1_URS;
    507            }
    508            else
    509            {
    510              /* Reset the URS Bit */
    511              TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
    512            }
    513          }
    514          
    515          /**
    516            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    517            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    518            * @param  NewState: new state of the TIMx peripheral Preload register
    519            *          This parameter can be: ENABLE or DISABLE.
    520            * @retval None
    521            */
    522          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    523          {
    524            /* Check the parameters */
    525            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    526            assert_param(IS_FUNCTIONAL_STATE(NewState));
    527          
    528            if (NewState != DISABLE)
    529            {
    530              /* Set the ARR Preload Bit */
    531              TIMx->CR1 |= TIM_CR1_ARPE;
    532            }
    533            else
    534            {
    535              /* Reset the ARR Preload Bit */
    536              TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
    537            }
    538          }
    539          
    540          /**
    541            * @brief  Selects the TIMx's One Pulse Mode.
    542            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    543            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    544            *          This parameter can be one of the following values:
    545            *            @arg TIM_OPMode_Single
    546            *            @arg TIM_OPMode_Repetitive
    547            * @retval None
    548            */
    549          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
    550          {
    551            /* Check the parameters */
    552            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    553            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
    554          
    555            /* Reset the OPM Bit */
    556            TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
    557          
    558            /* Configure the OPM Mode */
    559            TIMx->CR1 |= TIM_OPMode;
    560          }
    561          
    562          /**
    563            * @brief  Sets the TIMx Clock Division value.
    564            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    565            * @param  TIM_CKD: specifies the clock division value.
    566            *          This parameter can be one of the following value:
    567            *            @arg TIM_CKD_DIV1: TDTS = Tck_tim
    568            *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
    569            *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
    570            * @retval None
    571            */
    572          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
    573          {
    574            /* Check the parameters */
    575            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    576            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
    577          
    578            /* Reset the CKD Bits */
    579            TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
    580          
    581            /* Set the CKD value */
    582            TIMx->CR1 |= TIM_CKD;
    583          }
    584          
    585          /**
    586            * @brief  Enables or disables the specified TIM peripheral.
    587            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
    588            * @param  NewState: new state of the TIMx peripheral.
    589            *          This parameter can be: ENABLE or DISABLE.
    590            * @retval None
    591            */
    592          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    593          {
    594            /* Check the parameters */
    595            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    596            assert_param(IS_FUNCTIONAL_STATE(NewState));
    597            
    598            if (NewState != DISABLE)
    599            {
    600              /* Enable the TIM Counter */
    601              TIMx->CR1 |= TIM_CR1_CEN;
    602            }
    603            else
    604            {
    605              /* Disable the TIM Counter */
    606              TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
    607            }
    608          }
    609          /**
    610            * @}
    611            */
    612          
    613          /** @defgroup TIM_Group2 Output Compare management functions
    614           *  @brief    Output Compare management functions 
    615           *
    616          @verbatim   
    617           ===============================================================================
    618                                  Output Compare management functions
    619           ===============================================================================  
    620             
    621                 ===================================================================      
    622                        TIM Driver: how to use it in Output Compare Mode
    623                 =================================================================== 
    624                 To use the Timer in Output Compare mode, the following steps are mandatory:
    625                 
    626                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    627                 
    628                 2. Configure the TIM pins by configuring the corresponding GPIO pins
    629                 
    630                 2. Configure the Time base unit as described in the first part of this driver, 
    631                    if needed, else the Timer will run with the default configuration:
    632                    - Autoreload value = 0xFFFF
    633                    - Prescaler value = 0x0000
    634                    - Counter mode = Up counting
    635                    - Clock Division = TIM_CKD_DIV1
    636                    
    637                 3. Fill the TIM_OCInitStruct with the desired parameters including:
    638                    - The TIM Output Compare mode: TIM_OCMode
    639                    - TIM Output State: TIM_OutputState
    640                    - TIM Pulse value: TIM_Pulse
    641                    - TIM Output Compare Polarity : TIM_OCPolarity
    642                 
    643                 4. Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired channel with the 
    644                    corresponding configuration
    645                 
    646                 5. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    647                 
    648                 Note1: All other functions can be used separately to modify, if needed,
    649                        a specific feature of the Timer. 
    650                    
    651                 Note2: In case of PWM mode, this function is mandatory:
    652                        TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
    653                        
    654                 Note3: If the corresponding interrupt or DMA request are needed, the user should:
    655                          1. Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests). 
    656                          2. Enable the corresponding interrupt (or DMA request) using the function 
    657                             TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx))   
    658          
    659          @endverbatim
    660            * @{
    661            */
    662          
    663          /**
    664            * @brief  Initializes the TIMx Channel1 according to the specified parameters in
    665            *         the TIM_OCInitStruct.
    666            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    667            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    668            *         the configuration information for the specified TIM peripheral.
    669            * @retval None
    670            */
    671          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    672          {
    673            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    674             
    675            /* Check the parameters */
    676            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
    677            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    678            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    679            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    680          
    681            /* Disable the Channel 1: Reset the CC1E Bit */
    682            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
    683            
    684            /* Get the TIMx CCER register value */
    685            tmpccer = TIMx->CCER;
    686            /* Get the TIMx CR2 register value */
    687            tmpcr2 =  TIMx->CR2;
    688            
    689            /* Get the TIMx CCMR1 register value */
    690            tmpccmrx = TIMx->CCMR1;
    691              
    692            /* Reset the Output Compare Mode Bits */
    693            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
    694            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
    695            /* Select the Output Compare Mode */
    696            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    697            
    698            /* Reset the Output Polarity level */
    699            tmpccer &= (uint16_t)~TIM_CCER_CC1P;
    700            /* Set the Output Compare Polarity */
    701            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    702            
    703            /* Set the Output State */
    704            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    705              
    706            if((TIMx == TIM1) || (TIMx == TIM8))
    707            {
    708              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    709              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    710              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    711              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    712              
    713              /* Reset the Output N Polarity level */
    714              tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    715              /* Set the Output N Polarity */
    716              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    717              /* Reset the Output N State */
    718              tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    719              
    720              /* Set the Output N State */
    721              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    722              /* Reset the Output Compare and Output Compare N IDLE State */
    723              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    724              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    725              /* Set the Output Idle state */
    726              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    727              /* Set the Output N Idle state */
    728              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
    729            }
    730            /* Write to TIMx CR2 */
    731            TIMx->CR2 = tmpcr2;
    732            
    733            /* Write to TIMx CCMR1 */
    734            TIMx->CCMR1 = tmpccmrx;
    735            
    736            /* Set the Capture Compare Register value */
    737            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    738            
    739            /* Write to TIMx CCER */
    740            TIMx->CCER = tmpccer;
    741          }
    742          
    743          /**
    744            * @brief  Initializes the TIMx Channel2 according to the specified parameters 
    745            *         in the TIM_OCInitStruct.
    746            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
    747            *         peripheral.
    748            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    749            *         the configuration information for the specified TIM peripheral.
    750            * @retval None
    751            */
    752          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    753          {
    754            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    755             
    756            /* Check the parameters */
    757            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
    758            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    759            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    760            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    761          
    762            /* Disable the Channel 2: Reset the CC2E Bit */
    763            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
    764            
    765            /* Get the TIMx CCER register value */  
    766            tmpccer = TIMx->CCER;
    767            /* Get the TIMx CR2 register value */
    768            tmpcr2 =  TIMx->CR2;
    769            
    770            /* Get the TIMx CCMR1 register value */
    771            tmpccmrx = TIMx->CCMR1;
    772              
    773            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    774            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
    775            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
    776            
    777            /* Select the Output Compare Mode */
    778            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    779            
    780            /* Reset the Output Polarity level */
    781            tmpccer &= (uint16_t)~TIM_CCER_CC2P;
    782            /* Set the Output Compare Polarity */
    783            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    784            
    785            /* Set the Output State */
    786            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    787              
    788            if((TIMx == TIM1) || (TIMx == TIM8))
    789            {
    790              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    791              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    792              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    793              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    794              
    795              /* Reset the Output N Polarity level */
    796              tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    797              /* Set the Output N Polarity */
    798              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    799              /* Reset the Output N State */
    800              tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    801              
    802              /* Set the Output N State */
    803              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    804              /* Reset the Output Compare and Output Compare N IDLE State */
    805              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    806              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    807              /* Set the Output Idle state */
    808              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    809              /* Set the Output N Idle state */
    810              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    811            }
    812            /* Write to TIMx CR2 */
    813            TIMx->CR2 = tmpcr2;
    814            
    815            /* Write to TIMx CCMR1 */
    816            TIMx->CCMR1 = tmpccmrx;
    817            
    818            /* Set the Capture Compare Register value */
    819            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    820            
    821            /* Write to TIMx CCER */
    822            TIMx->CCER = tmpccer;
    823          }
    824          
    825          /**
    826            * @brief  Initializes the TIMx Channel3 according to the specified parameters
    827            *         in the TIM_OCInitStruct.
    828            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    829            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    830            *         the configuration information for the specified TIM peripheral.
    831            * @retval None
    832            */
    833          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    834          {
    835            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    836             
    837            /* Check the parameters */
    838            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    839            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    840            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    841            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    842          
    843            /* Disable the Channel 3: Reset the CC2E Bit */
    844            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
    845            
    846            /* Get the TIMx CCER register value */
    847            tmpccer = TIMx->CCER;
    848            /* Get the TIMx CR2 register value */
    849            tmpcr2 =  TIMx->CR2;
    850            
    851            /* Get the TIMx CCMR2 register value */
    852            tmpccmrx = TIMx->CCMR2;
    853              
    854            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    855            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
    856            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
    857            /* Select the Output Compare Mode */
    858            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    859            
    860            /* Reset the Output Polarity level */
    861            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
    862            /* Set the Output Compare Polarity */
    863            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    864            
    865            /* Set the Output State */
    866            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    867              
    868            if((TIMx == TIM1) || (TIMx == TIM8))
    869            {
    870              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    871              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    872              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    873              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    874              
    875              /* Reset the Output N Polarity level */
    876              tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    877              /* Set the Output N Polarity */
    878              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    879              /* Reset the Output N State */
    880              tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    881              
    882              /* Set the Output N State */
    883              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    884              /* Reset the Output Compare and Output Compare N IDLE State */
    885              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    886              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    887              /* Set the Output Idle state */
    888              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    889              /* Set the Output N Idle state */
    890              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
    891            }
    892            /* Write to TIMx CR2 */
    893            TIMx->CR2 = tmpcr2;
    894            
    895            /* Write to TIMx CCMR2 */
    896            TIMx->CCMR2 = tmpccmrx;
    897            
    898            /* Set the Capture Compare Register value */
    899            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    900            
    901            /* Write to TIMx CCER */
    902            TIMx->CCER = tmpccer;
    903          }
    904          
    905          /**
    906            * @brief  Initializes the TIMx Channel4 according to the specified parameters
    907            *         in the TIM_OCInitStruct.
    908            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    909            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    910            *         the configuration information for the specified TIM peripheral.
    911            * @retval None
    912            */
    913          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    914          {
    915            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    916             
    917            /* Check the parameters */
    918            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    919            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    920            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    921            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    922          
    923            /* Disable the Channel 4: Reset the CC4E Bit */
    924            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
    925            
    926            /* Get the TIMx CCER register value */
    927            tmpccer = TIMx->CCER;
    928            /* Get the TIMx CR2 register value */
    929            tmpcr2 =  TIMx->CR2;
    930            
    931            /* Get the TIMx CCMR2 register value */
    932            tmpccmrx = TIMx->CCMR2;
    933              
    934            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    935            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
    936            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
    937            
    938            /* Select the Output Compare Mode */
    939            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    940            
    941            /* Reset the Output Polarity level */
    942            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
    943            /* Set the Output Compare Polarity */
    944            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    945            
    946            /* Set the Output State */
    947            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    948            
    949            if((TIMx == TIM1) || (TIMx == TIM8))
    950            {
    951              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    952              /* Reset the Output Compare IDLE State */
    953              tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    954              /* Set the Output Idle state */
    955              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
    956            }
    957            /* Write to TIMx CR2 */
    958            TIMx->CR2 = tmpcr2;
    959            
    960            /* Write to TIMx CCMR2 */  
    961            TIMx->CCMR2 = tmpccmrx;
    962              
    963            /* Set the Capture Compare Register value */
    964            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    965            
    966            /* Write to TIMx CCER */
    967            TIMx->CCER = tmpccer;
    968          }
    969          
    970          /**
    971            * @brief  Fills each TIM_OCInitStruct member with its default value.
    972            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
    973            *         be initialized.
    974            * @retval None
    975            */
    976          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    977          {
    978            /* Set the default configuration */
    979            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    980            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    981            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
    982            TIM_OCInitStruct->TIM_Pulse = 0x00000000;
    983            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    984            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
    985            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
    986            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
    987          }
    988          
    989          /**
    990            * @brief  Selects the TIM Output Compare Mode.
    991            * @note   This function disables the selected channel before changing the Output
    992            *         Compare Mode. If needed, user has to enable this channel using
    993            *         TIM_CCxCmd() and TIM_CCxNCmd() functions.
    994            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    995            * @param  TIM_Channel: specifies the TIM Channel
    996            *          This parameter can be one of the following values:
    997            *            @arg TIM_Channel_1: TIM Channel 1
    998            *            @arg TIM_Channel_2: TIM Channel 2
    999            *            @arg TIM_Channel_3: TIM Channel 3
   1000            *            @arg TIM_Channel_4: TIM Channel 4
   1001            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
   1002            *           This parameter can be one of the following values:
   1003            *            @arg TIM_OCMode_Timing
   1004            *            @arg TIM_OCMode_Active
   1005            *            @arg TIM_OCMode_Toggle
   1006            *            @arg TIM_OCMode_PWM1
   1007            *            @arg TIM_OCMode_PWM2
   1008            *            @arg TIM_ForcedAction_Active
   1009            *            @arg TIM_ForcedAction_InActive
   1010            * @retval None
   1011            */
   1012          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   1013          {
   1014            uint32_t tmp = 0;
   1015            uint16_t tmp1 = 0;
   1016          
   1017            /* Check the parameters */
   1018            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1019            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1020            assert_param(IS_TIM_OCM(TIM_OCMode));
   1021          
   1022            tmp = (uint32_t) TIMx;
   1023            tmp += CCMR_OFFSET;
   1024          
   1025            tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
   1026          
   1027            /* Disable the Channel: Reset the CCxE Bit */
   1028            TIMx->CCER &= (uint16_t) ~tmp1;
   1029          
   1030            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   1031            {
   1032              tmp += (TIM_Channel>>1);
   1033          
   1034              /* Reset the OCxM bits in the CCMRx register */
   1035              *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
   1036             
   1037              /* Configure the OCxM bits in the CCMRx register */
   1038              *(__IO uint32_t *) tmp |= TIM_OCMode;
   1039            }
   1040            else
   1041            {
   1042              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   1043          
   1044              /* Reset the OCxM bits in the CCMRx register */
   1045              *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
   1046              
   1047              /* Configure the OCxM bits in the CCMRx register */
   1048              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   1049            }
   1050          }
   1051          
   1052          /**
   1053            * @brief  Sets the TIMx Capture Compare1 Register value
   1054            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1055            * @param  Compare1: specifies the Capture Compare1 register new value.
   1056            * @retval None
   1057            */
   1058          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
   1059          {
   1060            /* Check the parameters */
   1061            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1062          
   1063            /* Set the Capture Compare1 Register value */
   1064            TIMx->CCR1 = Compare1;
   1065          }
   1066          
   1067          /**
   1068            * @brief  Sets the TIMx Capture Compare2 Register value
   1069            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1070            *         peripheral.
   1071            * @param  Compare2: specifies the Capture Compare2 register new value.
   1072            * @retval None
   1073            */
   1074          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
   1075          {
   1076            /* Check the parameters */
   1077            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1078          
   1079            /* Set the Capture Compare2 Register value */
   1080            TIMx->CCR2 = Compare2;
   1081          }
   1082          
   1083          /**
   1084            * @brief  Sets the TIMx Capture Compare3 Register value
   1085            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1086            * @param  Compare3: specifies the Capture Compare3 register new value.
   1087            * @retval None
   1088            */
   1089          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
   1090          {
   1091            /* Check the parameters */
   1092            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1093          
   1094            /* Set the Capture Compare3 Register value */
   1095            TIMx->CCR3 = Compare3;
   1096          }
   1097          
   1098          /**
   1099            * @brief  Sets the TIMx Capture Compare4 Register value
   1100            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1101            * @param  Compare4: specifies the Capture Compare4 register new value.
   1102            * @retval None
   1103            */
   1104          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
   1105          {
   1106            /* Check the parameters */
   1107            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1108          
   1109            /* Set the Capture Compare4 Register value */
   1110            TIMx->CCR4 = Compare4;
   1111          }
   1112          
   1113          /**
   1114            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1115            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1116            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1117            *          This parameter can be one of the following values:
   1118            *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1119            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1120            * @retval None
   1121            */
   1122          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1123          {
   1124            uint16_t tmpccmr1 = 0;
   1125          
   1126            /* Check the parameters */
   1127            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1128            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1129            tmpccmr1 = TIMx->CCMR1;
   1130          
   1131            /* Reset the OC1M Bits */
   1132            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
   1133          
   1134            /* Configure The Forced output Mode */
   1135            tmpccmr1 |= TIM_ForcedAction;
   1136          
   1137            /* Write to TIMx CCMR1 register */
   1138            TIMx->CCMR1 = tmpccmr1;
   1139          }
   1140          
   1141          /**
   1142            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1143            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1144            *         peripheral.
   1145            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1146            *          This parameter can be one of the following values:
   1147            *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1148            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1149            * @retval None
   1150            */
   1151          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1152          {
   1153            uint16_t tmpccmr1 = 0;
   1154          
   1155            /* Check the parameters */
   1156            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1157            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1158            tmpccmr1 = TIMx->CCMR1;
   1159          
   1160            /* Reset the OC2M Bits */
   1161            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
   1162          
   1163            /* Configure The Forced output Mode */
   1164            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   1165          
   1166            /* Write to TIMx CCMR1 register */
   1167            TIMx->CCMR1 = tmpccmr1;
   1168          }
   1169          
   1170          /**
   1171            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1172            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1173            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1174            *          This parameter can be one of the following values:
   1175            *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1176            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1177            * @retval None
   1178            */
   1179          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1180          {
   1181            uint16_t tmpccmr2 = 0;
   1182          
   1183            /* Check the parameters */
   1184            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1185            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1186          
   1187            tmpccmr2 = TIMx->CCMR2;
   1188          
   1189            /* Reset the OC1M Bits */
   1190            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
   1191          
   1192            /* Configure The Forced output Mode */
   1193            tmpccmr2 |= TIM_ForcedAction;
   1194          
   1195            /* Write to TIMx CCMR2 register */
   1196            TIMx->CCMR2 = tmpccmr2;
   1197          }
   1198          
   1199          /**
   1200            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1201            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1202            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1203            *          This parameter can be one of the following values:
   1204            *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1205            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1206            * @retval None
   1207            */
   1208          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1209          {
   1210            uint16_t tmpccmr2 = 0;
   1211          
   1212            /* Check the parameters */
   1213            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1214            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1215            tmpccmr2 = TIMx->CCMR2;
   1216          
   1217            /* Reset the OC2M Bits */
   1218            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
   1219          
   1220            /* Configure The Forced output Mode */
   1221            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1222          
   1223            /* Write to TIMx CCMR2 register */
   1224            TIMx->CCMR2 = tmpccmr2;
   1225          }
   1226          
   1227          /**
   1228            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1229            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1230            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1231            *          This parameter can be one of the following values:
   1232            *            @arg TIM_OCPreload_Enable
   1233            *            @arg TIM_OCPreload_Disable
   1234            * @retval None
   1235            */
   1236          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1237          {
   1238            uint16_t tmpccmr1 = 0;
   1239          
   1240            /* Check the parameters */
   1241            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1242            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1243          
   1244            tmpccmr1 = TIMx->CCMR1;
   1245          
   1246            /* Reset the OC1PE Bit */
   1247            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
   1248          
   1249            /* Enable or Disable the Output Compare Preload feature */
   1250            tmpccmr1 |= TIM_OCPreload;
   1251          
   1252            /* Write to TIMx CCMR1 register */
   1253            TIMx->CCMR1 = tmpccmr1;
   1254          }
   1255          
   1256          /**
   1257            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1258            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1259            *         peripheral.
   1260            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1261            *          This parameter can be one of the following values:
   1262            *            @arg TIM_OCPreload_Enable
   1263            *            @arg TIM_OCPreload_Disable
   1264            * @retval None
   1265            */
   1266          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1267          {
   1268            uint16_t tmpccmr1 = 0;
   1269          
   1270            /* Check the parameters */
   1271            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1272            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1273          
   1274            tmpccmr1 = TIMx->CCMR1;
   1275          
   1276            /* Reset the OC2PE Bit */
   1277            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
   1278          
   1279            /* Enable or Disable the Output Compare Preload feature */
   1280            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1281          
   1282            /* Write to TIMx CCMR1 register */
   1283            TIMx->CCMR1 = tmpccmr1;
   1284          }
   1285          
   1286          /**
   1287            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1288            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1289            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1290            *          This parameter can be one of the following values:
   1291            *            @arg TIM_OCPreload_Enable
   1292            *            @arg TIM_OCPreload_Disable
   1293            * @retval None
   1294            */
   1295          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1296          {
   1297            uint16_t tmpccmr2 = 0;
   1298          
   1299            /* Check the parameters */
   1300            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1301            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1302          
   1303            tmpccmr2 = TIMx->CCMR2;
   1304          
   1305            /* Reset the OC3PE Bit */
   1306            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
   1307          
   1308            /* Enable or Disable the Output Compare Preload feature */
   1309            tmpccmr2 |= TIM_OCPreload;
   1310          
   1311            /* Write to TIMx CCMR2 register */
   1312            TIMx->CCMR2 = tmpccmr2;
   1313          }
   1314          
   1315          /**
   1316            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1317            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1318            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1319            *          This parameter can be one of the following values:
   1320            *            @arg TIM_OCPreload_Enable
   1321            *            @arg TIM_OCPreload_Disable
   1322            * @retval None
   1323            */
   1324          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1325          {
   1326            uint16_t tmpccmr2 = 0;
   1327          
   1328            /* Check the parameters */
   1329            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1330            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1331          
   1332            tmpccmr2 = TIMx->CCMR2;
   1333          
   1334            /* Reset the OC4PE Bit */
   1335            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
   1336          
   1337            /* Enable or Disable the Output Compare Preload feature */
   1338            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1339          
   1340            /* Write to TIMx CCMR2 register */
   1341            TIMx->CCMR2 = tmpccmr2;
   1342          }
   1343          
   1344          /**
   1345            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1346            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1347            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1348            *          This parameter can be one of the following values:
   1349            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1350            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1351            * @retval None
   1352            */
   1353          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1354          {
   1355            uint16_t tmpccmr1 = 0;
   1356          
   1357            /* Check the parameters */
   1358            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1359            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1360          
   1361            /* Get the TIMx CCMR1 register value */
   1362            tmpccmr1 = TIMx->CCMR1;
   1363          
   1364            /* Reset the OC1FE Bit */
   1365            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
   1366          
   1367            /* Enable or Disable the Output Compare Fast Bit */
   1368            tmpccmr1 |= TIM_OCFast;
   1369          
   1370            /* Write to TIMx CCMR1 */
   1371            TIMx->CCMR1 = tmpccmr1;
   1372          }
   1373          
   1374          /**
   1375            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1376            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1377            *         peripheral.
   1378            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1379            *          This parameter can be one of the following values:
   1380            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1381            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1382            * @retval None
   1383            */
   1384          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1385          {
   1386            uint16_t tmpccmr1 = 0;
   1387          
   1388            /* Check the parameters */
   1389            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1390            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1391          
   1392            /* Get the TIMx CCMR1 register value */
   1393            tmpccmr1 = TIMx->CCMR1;
   1394          
   1395            /* Reset the OC2FE Bit */
   1396            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
   1397          
   1398            /* Enable or Disable the Output Compare Fast Bit */
   1399            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1400          
   1401            /* Write to TIMx CCMR1 */
   1402            TIMx->CCMR1 = tmpccmr1;
   1403          }
   1404          
   1405          /**
   1406            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1407            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1408            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1409            *          This parameter can be one of the following values:
   1410            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1411            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1412            * @retval None
   1413            */
   1414          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1415          {
   1416            uint16_t tmpccmr2 = 0;
   1417            
   1418            /* Check the parameters */
   1419            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1420            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1421          
   1422            /* Get the TIMx CCMR2 register value */
   1423            tmpccmr2 = TIMx->CCMR2;
   1424          
   1425            /* Reset the OC3FE Bit */
   1426            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
   1427          
   1428            /* Enable or Disable the Output Compare Fast Bit */
   1429            tmpccmr2 |= TIM_OCFast;
   1430          
   1431            /* Write to TIMx CCMR2 */
   1432            TIMx->CCMR2 = tmpccmr2;
   1433          }
   1434          
   1435          /**
   1436            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1437            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1438            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1439            *          This parameter can be one of the following values:
   1440            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1441            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1442            * @retval None
   1443            */
   1444          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1445          {
   1446            uint16_t tmpccmr2 = 0;
   1447          
   1448            /* Check the parameters */
   1449            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1450            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1451          
   1452            /* Get the TIMx CCMR2 register value */
   1453            tmpccmr2 = TIMx->CCMR2;
   1454          
   1455            /* Reset the OC4FE Bit */
   1456            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
   1457          
   1458            /* Enable or Disable the Output Compare Fast Bit */
   1459            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1460          
   1461            /* Write to TIMx CCMR2 */
   1462            TIMx->CCMR2 = tmpccmr2;
   1463          }
   1464          
   1465          /**
   1466            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1467            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1468            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1469            *          This parameter can be one of the following values:
   1470            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1471            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1472            * @retval None
   1473            */
   1474          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1475          {
   1476            uint16_t tmpccmr1 = 0;
   1477          
   1478            /* Check the parameters */
   1479            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1480            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1481          
   1482            tmpccmr1 = TIMx->CCMR1;
   1483          
   1484            /* Reset the OC1CE Bit */
   1485            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
   1486          
   1487            /* Enable or Disable the Output Compare Clear Bit */
   1488            tmpccmr1 |= TIM_OCClear;
   1489          
   1490            /* Write to TIMx CCMR1 register */
   1491            TIMx->CCMR1 = tmpccmr1;
   1492          }
   1493          
   1494          /**
   1495            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1496            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1497            *         peripheral.
   1498            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1499            *          This parameter can be one of the following values:
   1500            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1501            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1502            * @retval None
   1503            */
   1504          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1505          {
   1506            uint16_t tmpccmr1 = 0;
   1507          
   1508            /* Check the parameters */
   1509            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1510            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1511          
   1512            tmpccmr1 = TIMx->CCMR1;
   1513          
   1514            /* Reset the OC2CE Bit */
   1515            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
   1516          
   1517            /* Enable or Disable the Output Compare Clear Bit */
   1518            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1519          
   1520            /* Write to TIMx CCMR1 register */
   1521            TIMx->CCMR1 = tmpccmr1;
   1522          }
   1523          
   1524          /**
   1525            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1526            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1527            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1528            *          This parameter can be one of the following values:
   1529            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1530            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1531            * @retval None
   1532            */
   1533          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1534          {
   1535            uint16_t tmpccmr2 = 0;
   1536          
   1537            /* Check the parameters */
   1538            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1539            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1540          
   1541            tmpccmr2 = TIMx->CCMR2;
   1542          
   1543            /* Reset the OC3CE Bit */
   1544            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
   1545          
   1546            /* Enable or Disable the Output Compare Clear Bit */
   1547            tmpccmr2 |= TIM_OCClear;
   1548          
   1549            /* Write to TIMx CCMR2 register */
   1550            TIMx->CCMR2 = tmpccmr2;
   1551          }
   1552          
   1553          /**
   1554            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1555            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1556            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1557            *          This parameter can be one of the following values:
   1558            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1559            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1560            * @retval None
   1561            */
   1562          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1563          {
   1564            uint16_t tmpccmr2 = 0;
   1565          
   1566            /* Check the parameters */
   1567            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1568            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1569          
   1570            tmpccmr2 = TIMx->CCMR2;
   1571          
   1572            /* Reset the OC4CE Bit */
   1573            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
   1574          
   1575            /* Enable or Disable the Output Compare Clear Bit */
   1576            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1577          
   1578            /* Write to TIMx CCMR2 register */
   1579            TIMx->CCMR2 = tmpccmr2;
   1580          }
   1581          
   1582          /**
   1583            * @brief  Configures the TIMx channel 1 polarity.
   1584            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1585            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1586            *          This parameter can be one of the following values:
   1587            *            @arg TIM_OCPolarity_High: Output Compare active high
   1588            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1589            * @retval None
   1590            */
   1591          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1592          {
   1593            uint16_t tmpccer = 0;
   1594          
   1595            /* Check the parameters */
   1596            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1597            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1598          
   1599            tmpccer = TIMx->CCER;
   1600          
   1601            /* Set or Reset the CC1P Bit */
   1602            tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
   1603            tmpccer |= TIM_OCPolarity;
   1604          
   1605            /* Write to TIMx CCER register */
   1606            TIMx->CCER = tmpccer;
   1607          }
   1608          
   1609          /**
   1610            * @brief  Configures the TIMx Channel 1N polarity.
   1611            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1612            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1613            *          This parameter can be one of the following values:
   1614            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1615            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1616            * @retval None
   1617            */
   1618          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1619          {
   1620            uint16_t tmpccer = 0;
   1621            /* Check the parameters */
   1622            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1623            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1624             
   1625            tmpccer = TIMx->CCER;
   1626          
   1627            /* Set or Reset the CC1NP Bit */
   1628            tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
   1629            tmpccer |= TIM_OCNPolarity;
   1630          
   1631            /* Write to TIMx CCER register */
   1632            TIMx->CCER = tmpccer;
   1633          }
   1634          
   1635          /**
   1636            * @brief  Configures the TIMx channel 2 polarity.
   1637            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1638            *         peripheral.
   1639            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1640            *          This parameter can be one of the following values:
   1641            *            @arg TIM_OCPolarity_High: Output Compare active high
   1642            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1643            * @retval None
   1644            */
   1645          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1646          {
   1647            uint16_t tmpccer = 0;
   1648          
   1649            /* Check the parameters */
   1650            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1651            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1652          
   1653            tmpccer = TIMx->CCER;
   1654          
   1655            /* Set or Reset the CC2P Bit */
   1656            tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
   1657            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1658          
   1659            /* Write to TIMx CCER register */
   1660            TIMx->CCER = tmpccer;
   1661          }
   1662          
   1663          /**
   1664            * @brief  Configures the TIMx Channel 2N polarity.
   1665            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1666            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1667            *          This parameter can be one of the following values:
   1668            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1669            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1670            * @retval None
   1671            */
   1672          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1673          {
   1674            uint16_t tmpccer = 0;
   1675          
   1676            /* Check the parameters */
   1677            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1678            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1679            
   1680            tmpccer = TIMx->CCER;
   1681          
   1682            /* Set or Reset the CC2NP Bit */
   1683            tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
   1684            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   1685          
   1686            /* Write to TIMx CCER register */
   1687            TIMx->CCER = tmpccer;
   1688          }
   1689          
   1690          /**
   1691            * @brief  Configures the TIMx channel 3 polarity.
   1692            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1693            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1694            *          This parameter can be one of the following values:
   1695            *            @arg TIM_OCPolarity_High: Output Compare active high
   1696            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1697            * @retval None
   1698            */
   1699          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1700          {
   1701            uint16_t tmpccer = 0;
   1702          
   1703            /* Check the parameters */
   1704            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1705            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1706          
   1707            tmpccer = TIMx->CCER;
   1708          
   1709            /* Set or Reset the CC3P Bit */
   1710            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
   1711            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1712          
   1713            /* Write to TIMx CCER register */
   1714            TIMx->CCER = tmpccer;
   1715          }
   1716          
   1717          /**
   1718            * @brief  Configures the TIMx Channel 3N polarity.
   1719            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1720            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1721            *          This parameter can be one of the following values:
   1722            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1723            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1724            * @retval None
   1725            */
   1726          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1727          {
   1728            uint16_t tmpccer = 0;
   1729           
   1730            /* Check the parameters */
   1731            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1732            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1733              
   1734            tmpccer = TIMx->CCER;
   1735          
   1736            /* Set or Reset the CC3NP Bit */
   1737            tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
   1738            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   1739          
   1740            /* Write to TIMx CCER register */
   1741            TIMx->CCER = tmpccer;
   1742          }
   1743          
   1744          /**
   1745            * @brief  Configures the TIMx channel 4 polarity.
   1746            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1747            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1748            *          This parameter can be one of the following values:
   1749            *            @arg TIM_OCPolarity_High: Output Compare active high
   1750            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1751            * @retval None
   1752            */
   1753          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1754          {
   1755            uint16_t tmpccer = 0;
   1756          
   1757            /* Check the parameters */
   1758            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1759            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1760          
   1761            tmpccer = TIMx->CCER;
   1762          
   1763            /* Set or Reset the CC4P Bit */
   1764            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
   1765            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1766          
   1767            /* Write to TIMx CCER register */
   1768            TIMx->CCER = tmpccer;
   1769          }
   1770          
   1771          /**
   1772            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1773            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1774            * @param  TIM_Channel: specifies the TIM Channel
   1775            *          This parameter can be one of the following values:
   1776            *            @arg TIM_Channel_1: TIM Channel 1
   1777            *            @arg TIM_Channel_2: TIM Channel 2
   1778            *            @arg TIM_Channel_3: TIM Channel 3
   1779            *            @arg TIM_Channel_4: TIM Channel 4
   1780            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1781            *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1782            * @retval None
   1783            */
   1784          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1785          {
   1786            uint16_t tmp = 0;
   1787          
   1788            /* Check the parameters */
   1789            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   1790            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1791            assert_param(IS_TIM_CCX(TIM_CCx));
   1792          
   1793            tmp = CCER_CCE_SET << TIM_Channel;
   1794          
   1795            /* Reset the CCxE Bit */
   1796            TIMx->CCER &= (uint16_t)~ tmp;
   1797          
   1798            /* Set or reset the CCxE Bit */ 
   1799            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   1800          }
   1801          
   1802          /**
   1803            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1804            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1805            * @param  TIM_Channel: specifies the TIM Channel
   1806            *          This parameter can be one of the following values:
   1807            *            @arg TIM_Channel_1: TIM Channel 1
   1808            *            @arg TIM_Channel_2: TIM Channel 2
   1809            *            @arg TIM_Channel_3: TIM Channel 3
   1810            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   1811            *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   1812            * @retval None
   1813            */
   1814          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   1815          {
   1816            uint16_t tmp = 0;
   1817          
   1818            /* Check the parameters */
   1819            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1820            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   1821            assert_param(IS_TIM_CCXN(TIM_CCxN));
   1822          
   1823            tmp = CCER_CCNE_SET << TIM_Channel;
   1824          
   1825            /* Reset the CCxNE Bit */
   1826            TIMx->CCER &= (uint16_t) ~tmp;
   1827          
   1828            /* Set or reset the CCxNE Bit */ 
   1829            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   1830          }
   1831          /**
   1832            * @}
   1833            */
   1834          
   1835          /** @defgroup TIM_Group3 Input Capture management functions
   1836           *  @brief    Input Capture management functions 
   1837           *
   1838          @verbatim   
   1839           ===============================================================================
   1840                                Input Capture management functions
   1841           ===============================================================================  
   1842             
   1843                 ===================================================================      
   1844                        TIM Driver: how to use it in Input Capture Mode
   1845                 =================================================================== 
   1846                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1847                 
   1848                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
   1849                 
   1850                 2. Configure the TIM pins by configuring the corresponding GPIO pins
   1851                 
   1852                 2. Configure the Time base unit as described in the first part of this driver,
   1853                    if needed, else the Timer will run with the default configuration:
   1854                    - Autoreload value = 0xFFFF
   1855                    - Prescaler value = 0x0000
   1856                    - Counter mode = Up counting
   1857                    - Clock Division = TIM_CKD_DIV1
   1858                    
   1859                 3. Fill the TIM_ICInitStruct with the desired parameters including:
   1860                    - TIM Channel: TIM_Channel
   1861                    - TIM Input Capture polarity: TIM_ICPolarity
   1862                    - TIM Input Capture selection: TIM_ICSelection
   1863                    - TIM Input Capture Prescaler: TIM_ICPrescaler
   1864                    - TIM Input CApture filter value: TIM_ICFilter
   1865                 
   1866                 4. Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired channel with the 
   1867                    corresponding configuration and to measure only frequency or duty cycle of the input signal,
   1868                    or,
   1869                    Call TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) to configure the desired channels with the 
   1870                    corresponding configuration and to measure the frequency and the duty cycle of the input signal
   1871                    
   1872                 5. Enable the NVIC or the DMA to read the measured frequency. 
   1873                    
   1874                 6. Enable the corresponding interrupt (or DMA request) to read the Captured value,
   1875                    using the function TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)) 
   1876                 
   1877                 7. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1878                 
   1879                 8. Use TIM_GetCapturex(TIMx); to read the captured value.
   1880                 
   1881                 Note1: All other functions can be used separately to modify, if needed,
   1882                        a specific feature of the Timer. 
   1883          
   1884          @endverbatim
   1885            * @{
   1886            */
   1887          
   1888          /**
   1889            * @brief  Initializes the TIM peripheral according to the specified parameters
   1890            *         in the TIM_ICInitStruct.
   1891            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1892            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1893            *         the configuration information for the specified TIM peripheral.
   1894            * @retval None
   1895            */
   1896          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1897          {
   1898            /* Check the parameters */     
   1899            assert_param(IS_TIM_LIST1_PERIPH(TIMx));   
   1900            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   1901            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   1902            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   1903            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   1904            
   1905            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1906            {
   1907              /* TI1 Configuration */
   1908              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1909                         TIM_ICInitStruct->TIM_ICSelection,
   1910                         TIM_ICInitStruct->TIM_ICFilter);
   1911              /* Set the Input Capture Prescaler value */
   1912              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1913            }
   1914            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   1915            {
   1916              /* TI2 Configuration */
   1917              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1918              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1919                         TIM_ICInitStruct->TIM_ICSelection,
   1920                         TIM_ICInitStruct->TIM_ICFilter);
   1921              /* Set the Input Capture Prescaler value */
   1922              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1923            }
   1924            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   1925            {
   1926              /* TI3 Configuration */
   1927              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1928              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1929                         TIM_ICInitStruct->TIM_ICSelection,
   1930                         TIM_ICInitStruct->TIM_ICFilter);
   1931              /* Set the Input Capture Prescaler value */
   1932              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1933            }
   1934            else
   1935            {
   1936              /* TI4 Configuration */ 
   1937              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1938              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1939                         TIM_ICInitStruct->TIM_ICSelection,
   1940                         TIM_ICInitStruct->TIM_ICFilter);
   1941              /* Set the Input Capture Prescaler value */
   1942              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1943            }
   1944          }
   1945          
   1946          /**
   1947            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1948            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
   1949            *         be initialized.
   1950            * @retval None
   1951            */
   1952          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1953          {
   1954            /* Set the default configuration */
   1955            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   1956            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   1957            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   1958            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   1959            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   1960          }
   1961          
   1962          /**
   1963            * @brief  Configures the TIM peripheral according to the specified parameters
   1964            *         in the TIM_ICInitStruct to measure an external PWM signal.
   1965            * @param  TIMx: where x can be  1, 2, 3, 4, 5,8, 9 or 12 to select the TIM 
   1966            *         peripheral.
   1967            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1968            *         the configuration information for the specified TIM peripheral.
   1969            * @retval None
   1970            */
   1971          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1972          {
   1973            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   1974            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   1975          
   1976            /* Check the parameters */
   1977            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1978          
   1979            /* Select the Opposite Input Polarity */
   1980            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   1981            {
   1982              icoppositepolarity = TIM_ICPolarity_Falling;
   1983            }
   1984            else
   1985            {
   1986              icoppositepolarity = TIM_ICPolarity_Rising;
   1987            }
   1988            /* Select the Opposite Input */
   1989            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   1990            {
   1991              icoppositeselection = TIM_ICSelection_IndirectTI;
   1992            }
   1993            else
   1994            {
   1995              icoppositeselection = TIM_ICSelection_DirectTI;
   1996            }
   1997            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1998            {
   1999              /* TI1 Configuration */
   2000              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2001                         TIM_ICInitStruct->TIM_ICFilter);
   2002              /* Set the Input Capture Prescaler value */
   2003              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2004              /* TI2 Configuration */
   2005              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2006              /* Set the Input Capture Prescaler value */
   2007              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2008            }
   2009            else
   2010            { 
   2011              /* TI2 Configuration */
   2012              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2013                         TIM_ICInitStruct->TIM_ICFilter);
   2014              /* Set the Input Capture Prescaler value */
   2015              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2016              /* TI1 Configuration */
   2017              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2018              /* Set the Input Capture Prescaler value */
   2019              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2020            }
   2021          }
   2022          
   2023          /**
   2024            * @brief  Gets the TIMx Input Capture 1 value.
   2025            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2026            * @retval Capture Compare 1 Register value.
   2027            */
   2028          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2029          {
   2030            /* Check the parameters */
   2031            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2032          
   2033            /* Get the Capture 1 Register value */
   2034            return TIMx->CCR1;
   2035          }
   2036          
   2037          /**
   2038            * @brief  Gets the TIMx Input Capture 2 value.
   2039            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2040            *         peripheral.
   2041            * @retval Capture Compare 2 Register value.
   2042            */
   2043          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2044          {
   2045            /* Check the parameters */
   2046            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2047          
   2048            /* Get the Capture 2 Register value */
   2049            return TIMx->CCR2;
   2050          }
   2051          
   2052          /**
   2053            * @brief  Gets the TIMx Input Capture 3 value.
   2054            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2055            * @retval Capture Compare 3 Register value.
   2056            */
   2057          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2058          {
   2059            /* Check the parameters */
   2060            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   2061          
   2062            /* Get the Capture 3 Register value */
   2063            return TIMx->CCR3;
   2064          }
   2065          
   2066          /**
   2067            * @brief  Gets the TIMx Input Capture 4 value.
   2068            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2069            * @retval Capture Compare 4 Register value.
   2070            */
   2071          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2072          {
   2073            /* Check the parameters */
   2074            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2075          
   2076            /* Get the Capture 4 Register value */
   2077            return TIMx->CCR4;
   2078          }
   2079          
   2080          /**
   2081            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2082            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2083            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2084            *          This parameter can be one of the following values:
   2085            *            @arg TIM_ICPSC_DIV1: no prescaler
   2086            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2087            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2088            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2089            * @retval None
   2090            */
   2091          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2092          {
   2093            /* Check the parameters */
   2094            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2095            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2096          
   2097            /* Reset the IC1PSC Bits */
   2098            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
   2099          
   2100            /* Set the IC1PSC value */
   2101            TIMx->CCMR1 |= TIM_ICPSC;
   2102          }
   2103          
   2104          /**
   2105            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2106            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2107            *         peripheral.
   2108            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2109            *          This parameter can be one of the following values:
   2110            *            @arg TIM_ICPSC_DIV1: no prescaler
   2111            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2112            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2113            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2114            * @retval None
   2115            */
   2116          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2117          {
   2118            /* Check the parameters */
   2119            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2120            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2121          
   2122            /* Reset the IC2PSC Bits */
   2123            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
   2124          
   2125            /* Set the IC2PSC value */
   2126            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   2127          }
   2128          
   2129          /**
   2130            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2131            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2132            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2133            *          This parameter can be one of the following values:
   2134            *            @arg TIM_ICPSC_DIV1: no prescaler
   2135            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2136            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2137            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2138            * @retval None
   2139            */
   2140          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2141          {
   2142            /* Check the parameters */
   2143            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2144            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2145          
   2146            /* Reset the IC3PSC Bits */
   2147            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
   2148          
   2149            /* Set the IC3PSC value */
   2150            TIMx->CCMR2 |= TIM_ICPSC;
   2151          }
   2152          
   2153          /**
   2154            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2155            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2156            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2157            *          This parameter can be one of the following values:
   2158            *            @arg TIM_ICPSC_DIV1: no prescaler
   2159            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2160            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2161            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2162            * @retval None
   2163            */
   2164          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2165          {  
   2166            /* Check the parameters */
   2167            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2168            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2169          
   2170            /* Reset the IC4PSC Bits */
   2171            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
   2172          
   2173            /* Set the IC4PSC value */
   2174            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   2175          }
   2176          /**
   2177            * @}
   2178            */
   2179          
   2180          /** @defgroup TIM_Group4 Advanced-control timers (TIM1 and TIM8) specific features
   2181           *  @brief   Advanced-control timers (TIM1 and TIM8) specific features
   2182           *
   2183          @verbatim   
   2184           ===============================================================================
   2185                    Advanced-control timers (TIM1 and TIM8) specific features
   2186           ===============================================================================  
   2187            
   2188                 ===================================================================      
   2189                        TIM Driver: how to use the Break feature
   2190                 =================================================================== 
   2191                 After configuring the Timer channel(s) in the appropriate Output Compare mode: 
   2192                                   
   2193                 1. Fill the TIM_BDTRInitStruct with the desired parameters for the Timer
   2194                    Break Polarity, dead time, Lock level, the OSSI/OSSR State and the 
   2195                    AOE(automatic output enable).
   2196                         
   2197                 2. Call TIM_BDTRConfig(TIMx, &TIM_BDTRInitStruct) to configure the Timer
   2198                    
   2199                 3. Enable the Main Output using TIM_CtrlPWMOutputs(TIM1, ENABLE) 
   2200                    
   2201                 4. Once the break even occurs, the Timer's output signals are put in reset
   2202                    state or in a known state (according to the configuration made in
   2203                    TIM_BDTRConfig() function).
   2204          
   2205          @endverbatim
   2206            * @{
   2207            */
   2208          
   2209          /**
   2210            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2211            *         and the AOE(automatic output enable).
   2212            * @param  TIMx: where x can be  1 or 8 to select the TIM 
   2213            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
   2214            *         contains the BDTR Register configuration  information for the TIM peripheral.
   2215            * @retval None
   2216            */
   2217          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
   2218          {
   2219            /* Check the parameters */
   2220            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2221            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
   2222            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
   2223            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
   2224            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
   2225            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
   2226            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
   2227          
   2228            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2229               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2230            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
   2231                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
   2232                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
   2233                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   2234          }
   2235          
   2236          /**
   2237            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
   2238            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
   2239            *         will be initialized.
   2240            * @retval None
   2241            */
   2242          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
   2243          {
   2244            /* Set the default configuration */
   2245            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   2246            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   2247            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   2248            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   2249            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   2250            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   2251            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   2252          }
   2253          
   2254          /**
   2255            * @brief  Enables or disables the TIM peripheral Main Outputs.
   2256            * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
   2257            * @param  NewState: new state of the TIM peripheral Main Outputs.
   2258            *          This parameter can be: ENABLE or DISABLE.
   2259            * @retval None
   2260            */
   2261          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
   2262          {
   2263            /* Check the parameters */
   2264            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2265            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2266          
   2267            if (NewState != DISABLE)
   2268            {
   2269              /* Enable the TIM Main Output */
   2270              TIMx->BDTR |= TIM_BDTR_MOE;
   2271            }
   2272            else
   2273            {
   2274              /* Disable the TIM Main Output */
   2275              TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
   2276            }  
   2277          }
   2278          
   2279          /**
   2280            * @brief  Selects the TIM peripheral Commutation event.
   2281            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2282            * @param  NewState: new state of the Commutation event.
   2283            *          This parameter can be: ENABLE or DISABLE.
   2284            * @retval None
   2285            */
   2286          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   2287          {
   2288            /* Check the parameters */
   2289            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2290            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2291          
   2292            if (NewState != DISABLE)
   2293            {
   2294              /* Set the COM Bit */
   2295              TIMx->CR2 |= TIM_CR2_CCUS;
   2296            }
   2297            else
   2298            {
   2299              /* Reset the COM Bit */
   2300              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
   2301            }
   2302          }
   2303          
   2304          /**
   2305            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   2306            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2307            * @param  NewState: new state of the Capture Compare Preload Control bit
   2308            *          This parameter can be: ENABLE or DISABLE.
   2309            * @retval None
   2310            */
   2311          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   2312          { 
   2313            /* Check the parameters */
   2314            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2315            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2316            if (NewState != DISABLE)
   2317            {
   2318              /* Set the CCPC Bit */
   2319              TIMx->CR2 |= TIM_CR2_CCPC;
   2320            }
   2321            else
   2322            {
   2323              /* Reset the CCPC Bit */
   2324              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
   2325            }
   2326          }
   2327          /**
   2328            * @}
   2329            */
   2330          
   2331          /** @defgroup TIM_Group5 Interrupts DMA and flags management functions
   2332           *  @brief    Interrupts, DMA and flags management functions 
   2333           *
   2334          @verbatim   
   2335           ===============================================================================
   2336                           Interrupts, DMA and flags management functions
   2337           ===============================================================================  
   2338          
   2339          @endverbatim
   2340            * @{
   2341            */
   2342          
   2343          /**
   2344            * @brief  Enables or disables the specified TIM interrupts.
   2345            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
   2346            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
   2347            *          This parameter can be any combination of the following values:
   2348            *            @arg TIM_IT_Update: TIM update Interrupt source
   2349            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2350            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2351            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2352            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2353            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2354            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2355            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2356            *  
   2357            * @note   For TIM6 and TIM7 only the parameter TIM_IT_Update can be used
   2358            * @note   For TIM9 and TIM12 only one of the following parameters can be used: TIM_IT_Update,
   2359            *          TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
   2360            * @note   For TIM10, TIM11, TIM13 and TIM14 only one of the following parameters can
   2361            *          be used: TIM_IT_Update or TIM_IT_CC1   
   2362            * @note   TIM_IT_COM and TIM_IT_Break can be used only with TIM1 and TIM8 
   2363            *        
   2364            * @param  NewState: new state of the TIM interrupts.
   2365            *          This parameter can be: ENABLE or DISABLE.
   2366            * @retval None
   2367            */
   2368          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
   2369          {  
   2370            /* Check the parameters */
   2371            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2372            assert_param(IS_TIM_IT(TIM_IT));
   2373            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2374            
   2375            if (NewState != DISABLE)
   2376            {
   2377              /* Enable the Interrupt sources */
   2378              TIMx->DIER |= TIM_IT;
   2379            }
   2380            else
   2381            {
   2382              /* Disable the Interrupt sources */
   2383              TIMx->DIER &= (uint16_t)~TIM_IT;
   2384            }
   2385          }
   2386          
   2387          /**
   2388            * @brief  Configures the TIMx event to be generate by software.
   2389            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2390            * @param  TIM_EventSource: specifies the event source.
   2391            *          This parameter can be one or more of the following values:	   
   2392            *            @arg TIM_EventSource_Update: Timer update Event source
   2393            *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   2394            *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   2395            *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   2396            *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   2397            *            @arg TIM_EventSource_COM: Timer COM event source  
   2398            *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
   2399            *            @arg TIM_EventSource_Break: Timer Break event source
   2400            * 
   2401            * @note   TIM6 and TIM7 can only generate an update event. 
   2402            * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
   2403            *        
   2404            * @retval None
   2405            */
   2406          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
   2407          { 
   2408            /* Check the parameters */
   2409            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2410            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   2411           
   2412            /* Set the event sources */
   2413            TIMx->EGR = TIM_EventSource;
   2414          }
   2415          
   2416          /**
   2417            * @brief  Checks whether the specified TIM flag is set or not.
   2418            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2419            * @param  TIM_FLAG: specifies the flag to check.
   2420            *          This parameter can be one of the following values:
   2421            *            @arg TIM_FLAG_Update: TIM update Flag
   2422            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2423            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2424            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2425            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2426            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2427            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2428            *            @arg TIM_FLAG_Break: TIM Break Flag
   2429            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2430            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2431            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2432            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2433            *
   2434            * @note   TIM6 and TIM7 can have only one update flag. 
   2435            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
   2436            *
   2437            * @retval The new state of TIM_FLAG (SET or RESET).
   2438            */
   2439          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2440          { 
   2441            ITStatus bitstatus = RESET;  
   2442            /* Check the parameters */
   2443            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2444            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2445          
   2446            
   2447            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   2448            {
   2449              bitstatus = SET;
   2450            }
   2451            else
   2452            {
   2453              bitstatus = RESET;
   2454            }
   2455            return bitstatus;
   2456          }
   2457          
   2458          /**
   2459            * @brief  Clears the TIMx's pending flags.
   2460            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2461            * @param  TIM_FLAG: specifies the flag bit to clear.
   2462            *          This parameter can be any combination of the following values:
   2463            *            @arg TIM_FLAG_Update: TIM update Flag
   2464            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2465            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2466            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2467            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2468            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2469            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2470            *            @arg TIM_FLAG_Break: TIM Break Flag
   2471            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2472            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2473            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2474            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2475            *
   2476            * @note   TIM6 and TIM7 can have only one update flag. 
   2477            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
   2478            *    
   2479            * @retval None
   2480            */
   2481          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2482          {  
   2483            /* Check the parameters */
   2484            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2485             
   2486            /* Clear the flags */
   2487            TIMx->SR = (uint16_t)~TIM_FLAG;
   2488          }
   2489          
   2490          /**
   2491            * @brief  Checks whether the TIM interrupt has occurred or not.
   2492            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2493            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2494            *          This parameter can be one of the following values:
   2495            *            @arg TIM_IT_Update: TIM update Interrupt source
   2496            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2497            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2498            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2499            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2500            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2501            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2502            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2503            *
   2504            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2505            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2506            *     
   2507            * @retval The new state of the TIM_IT(SET or RESET).
   2508            */
   2509          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2510          {
   2511            ITStatus bitstatus = RESET;  
   2512            uint16_t itstatus = 0x0, itenable = 0x0;
   2513            /* Check the parameters */
   2514            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2515            assert_param(IS_TIM_GET_IT(TIM_IT));
   2516             
   2517            itstatus = TIMx->SR & TIM_IT;
   2518            
   2519            itenable = TIMx->DIER & TIM_IT;
   2520            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   2521            {
   2522              bitstatus = SET;
   2523            }
   2524            else
   2525            {
   2526              bitstatus = RESET;
   2527            }
   2528            return bitstatus;
   2529          }
   2530          
   2531          /**
   2532            * @brief  Clears the TIMx's interrupt pending bits.
   2533            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2534            * @param  TIM_IT: specifies the pending bit to clear.
   2535            *          This parameter can be any combination of the following values:
   2536            *            @arg TIM_IT_Update: TIM1 update Interrupt source
   2537            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2538            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2539            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2540            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2541            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2542            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2543            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2544            *
   2545            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2546            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2547            *      
   2548            * @retval None
   2549            */
   2550          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2551          {
   2552            /* Check the parameters */
   2553            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2554          
   2555            /* Clear the IT pending Bit */
   2556            TIMx->SR = (uint16_t)~TIM_IT;
   2557          }
   2558          
   2559          /**
   2560            * @brief  Configures the TIMx's DMA interface.
   2561            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2562            * @param  TIM_DMABase: DMA Base address.
   2563            *          This parameter can be one of the following values:
   2564            *            @arg TIM_DMABase_CR1  
   2565            *            @arg TIM_DMABase_CR2
   2566            *            @arg TIM_DMABase_SMCR
   2567            *            @arg TIM_DMABase_DIER
   2568            *            @arg TIM1_DMABase_SR
   2569            *            @arg TIM_DMABase_EGR
   2570            *            @arg TIM_DMABase_CCMR1
   2571            *            @arg TIM_DMABase_CCMR2
   2572            *            @arg TIM_DMABase_CCER
   2573            *            @arg TIM_DMABase_CNT   
   2574            *            @arg TIM_DMABase_PSC   
   2575            *            @arg TIM_DMABase_ARR
   2576            *            @arg TIM_DMABase_RCR
   2577            *            @arg TIM_DMABase_CCR1
   2578            *            @arg TIM_DMABase_CCR2
   2579            *            @arg TIM_DMABase_CCR3  
   2580            *            @arg TIM_DMABase_CCR4
   2581            *            @arg TIM_DMABase_BDTR
   2582            *            @arg TIM_DMABase_DCR
   2583            * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
   2584            *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   2585            * @retval None
   2586            */
   2587          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
   2588          {
   2589            /* Check the parameters */
   2590            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2591            assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
   2592            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
   2593          
   2594            /* Set the DMA Base and the DMA Burst Length */
   2595            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   2596          }
   2597          
   2598          /**
   2599            * @brief  Enables or disables the TIMx's DMA Requests.
   2600            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2601            * @param  TIM_DMASource: specifies the DMA Request sources.
   2602            *          This parameter can be any combination of the following values:
   2603            *            @arg TIM_DMA_Update: TIM update Interrupt source
   2604            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   2605            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   2606            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   2607            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   2608            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   2609            *            @arg TIM_DMA_Trigger: TIM Trigger DMA source
   2610            * @param  NewState: new state of the DMA Request sources.
   2611            *          This parameter can be: ENABLE or DISABLE.
   2612            * @retval None
   2613            */
   2614          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
   2615          { 
   2616            /* Check the parameters */
   2617            assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
   2618            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
   2619            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2620            
   2621            if (NewState != DISABLE)
   2622            {
   2623              /* Enable the DMA sources */
   2624              TIMx->DIER |= TIM_DMASource; 
   2625            }
   2626            else
   2627            {
   2628              /* Disable the DMA sources */
   2629              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   2630            }
   2631          }
   2632          
   2633          /**
   2634            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   2635            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2636            * @param  NewState: new state of the Capture Compare DMA source
   2637            *          This parameter can be: ENABLE or DISABLE.
   2638            * @retval None
   2639            */
   2640          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   2641          {
   2642            /* Check the parameters */
   2643            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2644            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2645          
   2646            if (NewState != DISABLE)
   2647            {
   2648              /* Set the CCDS Bit */
   2649              TIMx->CR2 |= TIM_CR2_CCDS;
   2650            }
   2651            else
   2652            {
   2653              /* Reset the CCDS Bit */
   2654              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
   2655            }
   2656          }
   2657          /**
   2658            * @}
   2659            */
   2660          
   2661          /** @defgroup TIM_Group6 Clocks management functions
   2662           *  @brief    Clocks management functions
   2663           *
   2664          @verbatim   
   2665           ===============================================================================
   2666                                   Clocks management functions
   2667           ===============================================================================  
   2668          
   2669          @endverbatim
   2670            * @{
   2671            */
   2672          
   2673          /**
   2674            * @brief  Configures the TIMx internal Clock
   2675            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2676            *         peripheral.
   2677            * @retval None
   2678            */
   2679          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   2680          {
   2681            /* Check the parameters */
   2682            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2683          
   2684            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2685            TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
   2686          }
   2687          
   2688          /**
   2689            * @brief  Configures the TIMx Internal Trigger as External Clock
   2690            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2691            *         peripheral.
   2692            * @param  TIM_InputTriggerSource: Trigger source.
   2693            *          This parameter can be one of the following values:
   2694            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2695            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2696            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2697            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2698            * @retval None
   2699            */
   2700          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2701          {
   2702            /* Check the parameters */
   2703            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2704            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2705          
   2706            /* Select the Internal Trigger */
   2707            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   2708          
   2709            /* Select the External clock mode1 */
   2710            TIMx->SMCR |= TIM_SlaveMode_External1;
   2711          }
   2712          
   2713          /**
   2714            * @brief  Configures the TIMx Trigger as External Clock
   2715            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2716            *         to select the TIM peripheral.
   2717            * @param  TIM_TIxExternalCLKSource: Trigger source.
   2718            *          This parameter can be one of the following values:
   2719            *            @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   2720            *            @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   2721            *            @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   2722            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   2723            *          This parameter can be one of the following values:
   2724            *            @arg TIM_ICPolarity_Rising
   2725            *            @arg TIM_ICPolarity_Falling
   2726            * @param  ICFilter: specifies the filter value.
   2727            *          This parameter must be a value between 0x0 and 0xF.
   2728            * @retval None
   2729            */
   2730          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   2731                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   2732          {
   2733            /* Check the parameters */
   2734            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2735            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   2736            assert_param(IS_TIM_IC_FILTER(ICFilter));
   2737          
   2738            /* Configure the Timer Input Clock Source */
   2739            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   2740            {
   2741              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2742            }
   2743            else
   2744            {
   2745              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2746            }
   2747            /* Select the Trigger source */
   2748            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   2749            /* Select the External clock mode1 */
   2750            TIMx->SMCR |= TIM_SlaveMode_External1;
   2751          }
   2752          
   2753          /**
   2754            * @brief  Configures the External clock Mode1
   2755            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2756            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2757            *          This parameter can be one of the following values:
   2758            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2759            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2760            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2761            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2762            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2763            *          This parameter can be one of the following values:
   2764            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2765            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2766            * @param  ExtTRGFilter: External Trigger Filter.
   2767            *          This parameter must be a value between 0x00 and 0x0F
   2768            * @retval None
   2769            */
   2770          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   2771                                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2772          {
   2773            uint16_t tmpsmcr = 0;
   2774          
   2775            /* Check the parameters */
   2776            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2777            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2778            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2779            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2780            /* Configure the ETR Clock source */
   2781            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2782            
   2783            /* Get the TIMx SMCR register value */
   2784            tmpsmcr = TIMx->SMCR;
   2785          
   2786            /* Reset the SMS Bits */
   2787            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   2788          
   2789            /* Select the External clock mode1 */
   2790            tmpsmcr |= TIM_SlaveMode_External1;
   2791          
   2792            /* Select the Trigger selection : ETRF */
   2793            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2794            tmpsmcr |= TIM_TS_ETRF;
   2795          
   2796            /* Write to TIMx SMCR */
   2797            TIMx->SMCR = tmpsmcr;
   2798          }
   2799          
   2800          /**
   2801            * @brief  Configures the External clock Mode2
   2802            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2803            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2804            *          This parameter can be one of the following values:
   2805            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2806            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2807            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2808            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2809            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2810            *          This parameter can be one of the following values:
   2811            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2812            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2813            * @param  ExtTRGFilter: External Trigger Filter.
   2814            *          This parameter must be a value between 0x00 and 0x0F
   2815            * @retval None
   2816            */
   2817          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   2818                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2819          {
   2820            /* Check the parameters */
   2821            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2822            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2823            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2824            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2825          
   2826            /* Configure the ETR Clock source */
   2827            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2828          
   2829            /* Enable the External clock mode2 */
   2830            TIMx->SMCR |= TIM_SMCR_ECE;
   2831          }
   2832          /**
   2833            * @}
   2834            */
   2835          
   2836          /** @defgroup TIM_Group7 Synchronization management functions
   2837           *  @brief    Synchronization management functions 
   2838           *
   2839          @verbatim   
   2840           ===============================================================================
   2841                                 Synchronization management functions
   2842           ===============================================================================  
   2843                             
   2844                 ===================================================================      
   2845                        TIM Driver: how to use it in synchronization Mode
   2846                 =================================================================== 
   2847                 Case of two/several Timers
   2848                 **************************
   2849                 1. Configure the Master Timers using the following functions:
   2850                    - void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); 
   2851                    - void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);  
   2852                 2. Configure the Slave Timers using the following functions: 
   2853                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2854                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2855                    
   2856                 Case of Timers and external trigger(ETR pin)
   2857                 ********************************************       
   2858                 1. Configure the External trigger using this function:
   2859                    - void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2860                                         uint16_t ExtTRGFilter);
   2861                 2. Configure the Slave Timers using the following functions: 
   2862                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2863                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2864          
   2865          @endverbatim
   2866            * @{
   2867            */
   2868          
   2869          /**
   2870            * @brief  Selects the Input Trigger source
   2871            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2872            *         to select the TIM peripheral.
   2873            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2874            *          This parameter can be one of the following values:
   2875            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2876            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2877            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2878            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2879            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   2880            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   2881            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   2882            *            @arg TIM_TS_ETRF: External Trigger input
   2883            * @retval None
   2884            */
   2885          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2886          {
   2887            uint16_t tmpsmcr = 0;
   2888          
   2889            /* Check the parameters */
   2890            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   2891            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2892          
   2893            /* Get the TIMx SMCR register value */
   2894            tmpsmcr = TIMx->SMCR;
   2895          
   2896            /* Reset the TS Bits */
   2897            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2898          
   2899            /* Set the Input Trigger source */
   2900            tmpsmcr |= TIM_InputTriggerSource;
   2901          
   2902            /* Write to TIMx SMCR */
   2903            TIMx->SMCR = tmpsmcr;
   2904          }
   2905          
   2906          /**
   2907            * @brief  Selects the TIMx Trigger Output Mode.
   2908            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2909            *     
   2910            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2911            *   This parameter can be one of the following values:
   2912            *
   2913            *  - For all TIMx
   2914            *            @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output(TRGO)
   2915            *            @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output(TRGO)
   2916            *            @arg TIM_TRGOSource_Update: The update event is selected as the trigger output(TRGO)
   2917            *
   2918            *  - For all TIMx except TIM6 and TIM7
   2919            *            @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2920            *                                     is to be set, as soon as a capture or compare match occurs(TRGO)
   2921            *            @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output(TRGO)
   2922            *            @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output(TRGO)
   2923            *            @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output(TRGO)
   2924            *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
   2925            *
   2926            * @retval None
   2927            */
   2928          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2929          {
   2930            /* Check the parameters */
   2931            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   2932            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2933          
   2934            /* Reset the MMS Bits */
   2935            TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
   2936            /* Select the TRGO source */
   2937            TIMx->CR2 |=  TIM_TRGOSource;
   2938          }
   2939          
   2940          /**
   2941            * @brief  Selects the TIMx Slave Mode.
   2942            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2943            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2944            *          This parameter can be one of the following values:
   2945            *            @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal(TRGI) reinitialize 
   2946            *                                      the counter and triggers an update of the registers
   2947            *            @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high
   2948            *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
   2949            *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
   2950            * @retval None
   2951            */
   2952          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2953          {
   2954            /* Check the parameters */
   2955            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2956            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2957          
   2958            /* Reset the SMS Bits */
   2959            TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
   2960          
   2961            /* Select the Slave Mode */
   2962            TIMx->SMCR |= TIM_SlaveMode;
   2963          }
   2964          
   2965          /**
   2966            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2967            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2968            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2969            *          This parameter can be one of the following values:
   2970            *            @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2971            *                                             and its slaves (through TRGO)
   2972            *            @arg TIM_MasterSlaveMode_Disable: No action
   2973            * @retval None
   2974            */
   2975          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2976          {
   2977            /* Check the parameters */
   2978            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2979            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2980          
   2981            /* Reset the MSM Bit */
   2982            TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
   2983            
   2984            /* Set or Reset the MSM Bit */
   2985            TIMx->SMCR |= TIM_MasterSlaveMode;
   2986          }
   2987          
   2988          /**
   2989            * @brief  Configures the TIMx External Trigger (ETR).
   2990            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2991            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2992            *          This parameter can be one of the following values:
   2993            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2994            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2995            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2996            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2997            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2998            *          This parameter can be one of the following values:
   2999            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   3000            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   3001            * @param  ExtTRGFilter: External Trigger Filter.
   3002            *          This parameter must be a value between 0x00 and 0x0F
   3003            * @retval None
   3004            */
   3005          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   3006                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   3007          {
   3008            uint16_t tmpsmcr = 0;
   3009          
   3010            /* Check the parameters */
   3011            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   3012            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   3013            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   3014            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   3015          
   3016            tmpsmcr = TIMx->SMCR;
   3017          
   3018            /* Reset the ETR Bits */
   3019            tmpsmcr &= SMCR_ETR_MASK;
   3020          
   3021            /* Set the Prescaler, the Filter value and the Polarity */
   3022            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   3023          
   3024            /* Write to TIMx SMCR */
   3025            TIMx->SMCR = tmpsmcr;
   3026          }
   3027          /**
   3028            * @}
   3029            */
   3030          
   3031          /** @defgroup TIM_Group8 Specific interface management functions
   3032           *  @brief    Specific interface management functions 
   3033           *
   3034          @verbatim   
   3035           ===============================================================================
   3036                              Specific interface management functions
   3037           ===============================================================================  
   3038          
   3039          @endverbatim
   3040            * @{
   3041            */
   3042          
   3043          /**
   3044            * @brief  Configures the TIMx Encoder Interface.
   3045            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3046            *         peripheral.
   3047            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   3048            *          This parameter can be one of the following values:
   3049            *            @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   3050            *            @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   3051            *            @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   3052            *                                       on the level of the other input.
   3053            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   3054            *          This parameter can be one of the following values:
   3055            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3056            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3057            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   3058            *          This parameter can be one of the following values:
   3059            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3060            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3061            * @retval None
   3062            */
   3063          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   3064                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   3065          {
   3066            uint16_t tmpsmcr = 0;
   3067            uint16_t tmpccmr1 = 0;
   3068            uint16_t tmpccer = 0;
   3069              
   3070            /* Check the parameters */
   3071            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3072            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   3073            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   3074            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   3075          
   3076            /* Get the TIMx SMCR register value */
   3077            tmpsmcr = TIMx->SMCR;
   3078          
   3079            /* Get the TIMx CCMR1 register value */
   3080            tmpccmr1 = TIMx->CCMR1;
   3081          
   3082            /* Get the TIMx CCER register value */
   3083            tmpccer = TIMx->CCER;
   3084          
   3085            /* Set the encoder Mode */
   3086            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   3087            tmpsmcr |= TIM_EncoderMode;
   3088          
   3089            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   3090            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
   3091            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   3092          
   3093            /* Set the TI1 and the TI2 Polarities */
   3094            tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
   3095            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   3096          
   3097            /* Write to TIMx SMCR */
   3098            TIMx->SMCR = tmpsmcr;
   3099          
   3100            /* Write to TIMx CCMR1 */
   3101            TIMx->CCMR1 = tmpccmr1;
   3102          
   3103            /* Write to TIMx CCER */
   3104            TIMx->CCER = tmpccer;
   3105          }
   3106          
   3107          /**
   3108            * @brief  Enables or disables the TIMx's Hall sensor interface.
   3109            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3110            *         peripheral.
   3111            * @param  NewState: new state of the TIMx Hall sensor interface.
   3112            *          This parameter can be: ENABLE or DISABLE.
   3113            * @retval None
   3114            */
   3115          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   3116          {
   3117            /* Check the parameters */
   3118            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3119            assert_param(IS_FUNCTIONAL_STATE(NewState));
   3120          
   3121            if (NewState != DISABLE)
   3122            {
   3123              /* Set the TI1S Bit */
   3124              TIMx->CR2 |= TIM_CR2_TI1S;
   3125            }
   3126            else
   3127            {
   3128              /* Reset the TI1S Bit */
   3129              TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
   3130            }
   3131          }
   3132          /**
   3133            * @}
   3134            */
   3135          
   3136          /** @defgroup TIM_Group9 Specific remapping management function
   3137           *  @brief   Specific remapping management function
   3138           *
   3139          @verbatim   
   3140           ===============================================================================
   3141                               Specific remapping management function
   3142           ===============================================================================  
   3143          
   3144          @endverbatim
   3145            * @{
   3146            */
   3147          
   3148          /**
   3149            * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
   3150            * @param  TIMx: where x can be 2, 5 or 11 to select the TIM peripheral.
   3151            * @param  TIM_Remap: specifies the TIM input remapping source.
   3152            *          This parameter can be one of the following values:
   3153            *            @arg TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
   3154            *            @arg TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trogger output.
   3155            *            @arg TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
   3156            *            @arg TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
   3157            *            @arg TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
   3158            *            @arg TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
   3159            *            @arg TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
   3160            *            @arg TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
   3161            *            @arg TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
   3162            *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
   3163            *                                 (HSE divided by a programmable prescaler)  
   3164            * @retval None
   3165            */
   3166          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
   3167          {
   3168           /* Check the parameters */
   3169            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   3170            assert_param(IS_TIM_REMAP(TIM_Remap));
   3171          
   3172            /* Set the Timer remapping configuration */
   3173            TIMx->OR =  TIM_Remap;
   3174          }
   3175          /**
   3176            * @}
   3177            */
   3178          
   3179          /**
   3180            * @brief  Configure the TI1 as Input.
   3181            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   3182            *         to select the TIM peripheral.
   3183            * @param  TIM_ICPolarity : The Input Polarity.
   3184            *          This parameter can be one of the following values:
   3185            *            @arg TIM_ICPolarity_Rising
   3186            *            @arg TIM_ICPolarity_Falling
   3187            *            @arg TIM_ICPolarity_BothEdge  
   3188            * @param  TIM_ICSelection: specifies the input to be used.
   3189            *          This parameter can be one of the following values:
   3190            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   3191            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   3192            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   3193            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3194            *          This parameter must be a value between 0x00 and 0x0F.
   3195            * @retval None
   3196            */
   3197          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3198                                 uint16_t TIM_ICFilter)
   3199          {
   3200            uint16_t tmpccmr1 = 0, tmpccer = 0;
   3201          
   3202            /* Disable the Channel 1: Reset the CC1E Bit */
   3203            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
   3204            tmpccmr1 = TIMx->CCMR1;
   3205            tmpccer = TIMx->CCER;
   3206          
   3207            /* Select the Input and set the filter */
   3208            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
   3209            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3210          
   3211            /* Select the Polarity and set the CC1E Bit */
   3212            tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   3213            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   3214          
   3215            /* Write to TIMx CCMR1 and CCER registers */
   3216            TIMx->CCMR1 = tmpccmr1;
   3217            TIMx->CCER = tmpccer;
   3218          }
   3219          
   3220          /**
   3221            * @brief  Configure the TI2 as Input.
   3222            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3223            *         peripheral.
   3224            * @param  TIM_ICPolarity : The Input Polarity.
   3225            *          This parameter can be one of the following values:
   3226            *            @arg TIM_ICPolarity_Rising
   3227            *            @arg TIM_ICPolarity_Falling
   3228            *            @arg TIM_ICPolarity_BothEdge   
   3229            * @param  TIM_ICSelection: specifies the input to be used.
   3230            *          This parameter can be one of the following values:
   3231            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   3232            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   3233            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   3234            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3235            *          This parameter must be a value between 0x00 and 0x0F.
   3236            * @retval None
   3237            */
   3238          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3239                                 uint16_t TIM_ICFilter)
   3240          {
   3241            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   3242          
   3243            /* Disable the Channel 2: Reset the CC2E Bit */
   3244            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
   3245            tmpccmr1 = TIMx->CCMR1;
   3246            tmpccer = TIMx->CCER;
   3247            tmp = (uint16_t)(TIM_ICPolarity << 4);
   3248          
   3249            /* Select the Input and set the filter */
   3250            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3251            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   3252            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   3253          
   3254            /* Select the Polarity and set the CC2E Bit */
   3255            tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   3256            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   3257          
   3258            /* Write to TIMx CCMR1 and CCER registers */
   3259            TIMx->CCMR1 = tmpccmr1 ;
   3260            TIMx->CCER = tmpccer;
   3261          }
   3262          
   3263          /**
   3264            * @brief  Configure the TI3 as Input.
   3265            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3266            * @param  TIM_ICPolarity : The Input Polarity.
   3267            *          This parameter can be one of the following values:
   3268            *            @arg TIM_ICPolarity_Rising
   3269            *            @arg TIM_ICPolarity_Falling
   3270            *            @arg TIM_ICPolarity_BothEdge         
   3271            * @param  TIM_ICSelection: specifies the input to be used.
   3272            *          This parameter can be one of the following values:
   3273            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   3274            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   3275            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   3276            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3277            *          This parameter must be a value between 0x00 and 0x0F.
   3278            * @retval None
   3279            */
   3280          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3281                                 uint16_t TIM_ICFilter)
   3282          {
   3283            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3284          
   3285            /* Disable the Channel 3: Reset the CC3E Bit */
   3286            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
   3287            tmpccmr2 = TIMx->CCMR2;
   3288            tmpccer = TIMx->CCER;
   3289            tmp = (uint16_t)(TIM_ICPolarity << 8);
   3290          
   3291            /* Select the Input and set the filter */
   3292            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
   3293            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3294          
   3295            /* Select the Polarity and set the CC3E Bit */
   3296            tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   3297            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   3298          
   3299            /* Write to TIMx CCMR2 and CCER registers */
   3300            TIMx->CCMR2 = tmpccmr2;
   3301            TIMx->CCER = tmpccer;
   3302          }
   3303          
   3304          /**
   3305            * @brief  Configure the TI4 as Input.
   3306            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3307            * @param  TIM_ICPolarity : The Input Polarity.
   3308            *          This parameter can be one of the following values:
   3309            *            @arg TIM_ICPolarity_Rising
   3310            *            @arg TIM_ICPolarity_Falling
   3311            *            @arg TIM_ICPolarity_BothEdge     
   3312            * @param  TIM_ICSelection: specifies the input to be used.
   3313            *          This parameter can be one of the following values:
   3314            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   3315            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   3316            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   3317            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3318            *          This parameter must be a value between 0x00 and 0x0F.
   3319            * @retval None
   3320            */
   3321          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3322                                 uint16_t TIM_ICFilter)
   3323          {
   3324            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3325          
   3326            /* Disable the Channel 4: Reset the CC4E Bit */
   3327            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
   3328            tmpccmr2 = TIMx->CCMR2;
   3329            tmpccer = TIMx->CCER;
   3330            tmp = (uint16_t)(TIM_ICPolarity << 12);
   3331          
   3332            /* Select the Input and set the filter */
   3333            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3334            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   3335            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   3336          
   3337            /* Select the Polarity and set the CC4E Bit */
   3338            tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   3339            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   3340          
   3341            /* Write to TIMx CCMR2 and CCER registers */
   3342            TIMx->CCMR2 = tmpccmr2;
   3343            TIMx->CCER = tmpccer ;
   3344          }
   3345          
   3346          /**
   3347            * @}
   3348            */
   3349          
   3350          /**
   3351            * @}
   3352            */
   3353          
   3354          /**
   3355            * @}
   3356            */
   3357          
   3358          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   TIM_ARRPreloadConfig
       0   TIM_BDTRConfig
       0   TIM_BDTRStructInit
       0   TIM_CCPreloadControl
       0   TIM_CCxCmd
       0   TIM_CCxNCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       0   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       0   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       0   TIM_CounterModeConfig
       0   TIM_CtrlPWMOutputs
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   TIM_ETRClockMode1Config
       0   TIM_ETRClockMode2Config
       0   TIM_ETRConfig
      16   TIM_EncoderInterfaceConfig
       0   TIM_ForcedOC1Config
       0   TIM_ForcedOC2Config
       0   TIM_ForcedOC3Config
       0   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
       0   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
       0   TIM_ICStructInit
       0   TIM_ITConfig
       0   TIM_ITRxExternalClockConfig
       0   TIM_InternalClockConfig
       0   TIM_OC1FastConfig
       8   TIM_OC1Init
       0   TIM_OC1NPolarityConfig
       0   TIM_OC1PolarityConfig
       0   TIM_OC1PreloadConfig
       0   TIM_OC2FastConfig
      12   TIM_OC2Init
       0   TIM_OC2NPolarityConfig
       0   TIM_OC2PolarityConfig
       0   TIM_OC2PreloadConfig
       0   TIM_OC3FastConfig
      12   TIM_OC3Init
       0   TIM_OC3NPolarityConfig
       0   TIM_OC3PolarityConfig
       0   TIM_OC3PreloadConfig
       0   TIM_OC4FastConfig
      12   TIM_OC4Init
       0   TIM_OC4PolarityConfig
       0   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
       0   TIM_PrescalerConfig
       0   TIM_RemapConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectCOM
       0   TIM_SelectHallSensor
       0   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
       8   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      12   TIM_TIxExternalClockConfig
       4   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      22  ?Subroutine0
      12  ?Subroutine1
       6  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
      12  ?Subroutine2
      10  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
      10  ?Subroutine6
       8  ?Subroutine7
       8  ?Subroutine8
       8  ?Subroutine9
      20  TIM_ARRPreloadConfig
      28  TIM_BDTRConfig
      18  TIM_BDTRStructInit
      20  TIM_CCPreloadControl
       8  TIM_CCxCmd
       6  TIM_CCxNCmd
       2  TIM_ClearFlag
       2  TIM_ClearITPendingBit
       8  TIM_ClearOC1Ref
       8  TIM_ClearOC2Ref
       8  TIM_ClearOC3Ref
       8  TIM_ClearOC4Ref
      20  TIM_Cmd
      10  TIM_CounterModeConfig
      16  TIM_CtrlPWMOutputs
      16  TIM_DMACmd
       8  TIM_DMAConfig
     322  TIM_DeInit
      30  TIM_ETRClockMode1Config
      30  TIM_ETRClockMode2Config
      22  TIM_ETRConfig
      50  TIM_EncoderInterfaceConfig
       8  TIM_ForcedOC1Config
       8  TIM_ForcedOC2Config
       8  TIM_ForcedOC3Config
       8  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       4  TIM_GetCapture4
       4  TIM_GetCounter
      14  TIM_GetFlagStatus
      20  TIM_GetITStatus
       4  TIM_GetPrescaler
     280  TIM_ICInit
      18  TIM_ICStructInit
      16  TIM_ITConfig
      22  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
       8  TIM_OC1FastConfig
     102  TIM_OC1Init
       6  TIM_OC1NPolarityConfig
       8  TIM_OC1PolarityConfig
       6  TIM_OC1PreloadConfig
       8  TIM_OC2FastConfig
     108  TIM_OC2Init
       6  TIM_OC2NPolarityConfig
       8  TIM_OC2PolarityConfig
       6  TIM_OC2PreloadConfig
       8  TIM_OC3FastConfig
     104  TIM_OC3Init
       6  TIM_OC3NPolarityConfig
       8  TIM_OC3PolarityConfig
       6  TIM_OC3PreloadConfig
       8  TIM_OC4FastConfig
      80  TIM_OC4Init
      16  TIM_OC4PolarityConfig
       6  TIM_OC4PreloadConfig
      20  TIM_OCStructInit
     316  TIM_PWMIConfig
       6  TIM_PrescalerConfig
       6  TIM_RemapConfig
      20  TIM_SelectCCDMA
      20  TIM_SelectCOM
      20  TIM_SelectHallSensor
      10  TIM_SelectInputTrigger
       6  TIM_SelectMasterSlaveMode
      76  TIM_SelectOCxM
       8  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
       8  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
       6  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       4  TIM_SetCompare4
       4  TIM_SetCounter
      14  TIM_SetIC1Prescaler
      14  TIM_SetIC2Prescaler
      14  TIM_SetIC3Prescaler
      14  TIM_SetIC4Prescaler
     118  TIM_TIxExternalClockConfig
     102  TIM_TimeBaseInit
      18  TIM_TimeBaseStructInit
      20  TIM_UpdateDisableConfig
      20  TIM_UpdateRequestConfig

 
 2 688 bytes in section .text
 
 2 688 bytes of CODE memory

Errors: none
Warnings: none
